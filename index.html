<!doctype html>
<html>
    <head>
        <script src="https://js13kgames.com/webxr-src/babylon.js"></script>
        <style>
            body {margin:0;overflow:hidden;}
            #fps { position: absolute; left: 20px; top: 20px; color: #999; font-family: "Courier New", Courier, monospace }
        </style>
    </head>
    <body>
        <canvas id="jj" touch-action="none"></canvas>
        <div id="fps"></div>
    </body>
    <script>
        /*
            ######################################################
            ### Preparation
        */
       
        // Set canvas size
        can = document.getElementById("jj");
        can.width = window.innerWidth;
        can.height = window.innerHeight;

        // Babylon engine on
        engine = new BABYLON.Engine(can, true);

        /*
            ######################################################
            ### Variables
        */
       
        // Consts
        FONT     = "Consolas";
        GRIDSIZE = 8;
        GRIDWID  = 30/GRIDSIZE;
        DELTIME  = 30;
        DATABLKS = 200;
        DEF_EYES = "o"
       
        // Logo compressed
        logo = [15395444,11438676,13274198,11176533,15657558];
        
        // Camera position
        camOff = new BABYLON.Vector3(0, 0, 1);
        
        // Game state
        /*
            0 - Game not started yet
            1 - Logo is created
            2 - Game has started
        */
        gameState = 0;
        
        // Highlight layer
        var hl;
        
        // Materials
        logoMaterials = [];
        dataMaterials = [];
        var eqSlot, selGrid, selPGrid, nonGrid, curMat, wallMat, 
            entrMat, reflMat, selSlot, gridBackMat, heroMat, crystMat,
            splitterMat, splitter2Mat;
        
        // Game vars
        shakeCamera = 0;   // Camera shake level (0-3)
        
        actS = 0;      // Current memory size
        maxS = 13312;  // Total memory size
        dmgBuff = 0;   // Total damaged memory
        level = 0;     // Level we are playing right now
        exits = [0,0]  // Exited sucessfully/total exits
        
        slots = [[0,0],[0,0],[0,0],[0,0],[0,0]]; // Slot information
        slotC = -1;                              // Choosen toolbar slot
        
        gridPos = [];  // Position of all grid slots
        lasers = [];   // All created lasers
        
        delet = DELTIME;      // Time to delete object
        mouseDown = 0;        // Is mouse down on canvas
        gridC = -1;           // Choosen grid slot
        wantToPlace = false;  // Do we want to place smth on the grid
        
        reused = 0;
        
        var vojc,                // English voice
            hero,                // Body
            heroEyes,            // Eyes
            isHero = 0,          // Is hero created
            heroMov = 0,         // Calculate hero movement
            heroIsSpeaking = 1,  // Movement speed ratio
            dialogs = [],        // For ppl who has speechSynthesis disabled; Dialogs queue
            isTalking = false,   // For ppl who has speechSynthesis disabled; Check if hero is talking
            whichSequance = 0,   // Tells which dialog is spoken
            isHighlight = -1,    // Check if slot is highlighted
            subSize = 30,        // Set size of subtitles
            isHighMode = -1;     // Highlight mode
            
        var optVoice = 1,             // If true, speechSynthesis API is in use
            optQuality = 2,           // 0 - low, 1 - medium, 2 - high    
            optSensitiv = 300,        // Mouse sensitivity; Default: 300
            optAngle = Math.PI*0.25,  // Options rotation
            optAngle2 = Math.PI*1.75, // Options rotation
            optCanPlace = false;      // Check if placing/rotating/deleting is allowed [used for dialogs]
            
            
        var gameEnd = false,         // End of the game?
            skySeq = 0,              // Number used for animating ending sky
            achiv = 0,               // Unlocked achievements
            isGameover = false,      // Check if it's gameover
            stopCameraShake = false, // Should camera shake be stopped
            gameStarted = false,     // Has game started?
            memoLost = 0,            // Which text of "memory lost" to say
            gameWon = 0;             // Did we win?
            
        var VRhelper;   // VR experience helper
            
        // Array containing strings
        S = [
            "Click here to start playing", 
            "Memory size", 
            "Toolbar",
            "Reflector",
            "Game created by @holosiek & @bthefw",
            "Mirror",
            "<- Options",
            "Achievements ->",
            "Game ->",
            "<- Achievements",
            
            "Camera shake: ",               // 10
            "Animated logo: ",              // 11
            "Hero animations: ",            // 12
            "Objects animations: ",         // 13
            "Data blocks on the back: ",    // 14
            
            "Low",      // 15
            "Medium",   // 16
            "High",     // 17
            
            "Enabled",  // 18
            "Disabled", // 19
            
            "speechSynthesis API",  // 20
            
            "Crystal",    // 21
            "Splitter",   // 22
            
            "<- Game",    // 23
            "Options ->", // 24
        ];
        
        // Array containing level completed callouts
        E = [
            ["Good job!", 1.5],
            ["Very nice", 0.8],
            ["Outstanding!", 0.8]
        ];
        
        // Array containing colors
        C = [
            "#cacae7",
            "#8e8ecc",
            "#693e73",
            "#555555",
            "#777777",
            "#FFFFFF"
        ];
        
        LEVELS = [
            [[2294399266,1715535888],[9,9,9,6,9,9,9,9,9,9,9,9,2,9,9,9,9],[10,2]], // Place/Rotate/Destroy tutorial
            [[201326592,536903708],[9,7,1,9,9,9,9],[10,4]],
            [[2172747992,2122416513],[9,9,9,9,2,4,9,9,2,4,9,9,2,4,9,7,7,7,7,7,7],[10,6]],
            [[304120038,543966744],[9,9,9,9,9,9,9,4,14,9,7,9,9,9,9,9,9,9,9],[10,3]], // Crystal tutorial
            [[2416203009,58221060],[9,9,3,9,9,9,9,9,9,9,9,9,9,11,6,9,9,9],[10,6]],
            [[2610979967,3721063399],[1,11,10,11,11,10,10,10,10,10,10,10,10,10,11,10,13,10,11,10,10,11,11,11,10,10,10,10,10,10,10,10,11,10,11,7,11,11,11],[10,4]],
            [[134758400,20],[2,9,9,8,14],[10,1,12,2]], // Mirror tutorial
            [[16896,4325376],[5,1,14,14],[12,4]],
            [[4294901761,33619967],[4,14,15,14,15,15,14,14,15,14,14,14,15,15,14,15,14,15,15,14,14,15,15,15,14,14,14,15,15,15,14,14,14,7],[10,1]],
            [[182912,100794496],[9,8,9,5,9,9,9,4,9,9],[10,4,16,1]], // Splitter tutorial
            [[805572608,4734976],[1,11,11,9,6,10,6],[10,2,16,1]],
            [[24576,1048578],[1,5,8,7],[10,3,14,1,16,2]],
            [[16812313,10066176],[8,2,4,8,2,6,8,8,2,8,2,8,2,8,2],[10,3,16,1]],
            [[2164260888,2550136961],[5,5,8,6,8,6,7,7,3],[10,8,16,7]]
        ]
        
        // Game grid
        cubeGrid = Array(GRIDSIZE**2).fill({'type':'none','destructable':false})
        
        /*
            ######################################################
            ### Misc functions
        */
               
        // Return Babylon.js color
        tex = (r, g, b) => {
            return new BABYLON.Color3(r, g, b);
        }
        
        // Return Babylon.js standard material
        mate = (a_id, a_color, a_disLight=false) => {
            let a = new BABYLON.StandardMaterial(a_id, scene);
                a.emissiveColor = a_color;
                a.disableLighting = a_disLight;
            return a;
        }
        
        // Return Babylon.js vector
        vec3 = (x, y, z) => {
            return new BABYLON.Vector3(x, y, z);
        }
        
        // Return random number from -1 to 1
        randS = () => {
            let r = Math.random();
            return (Math.random()<=0.5)?r:-r;
        }
        
        // Random int from 0 to num-1
        ranRng = num => {
            return Math.floor(Math.random()*num);
        }
        
        // Return copy of the object
        copyObj = a_obj => {
            return JSON.parse(JSON.stringify(a_obj));
        }
        
        /*
            ######################################################
            ### Material creation
        */
       
        // Create all materials
        materialCreation = () => {
            // Create colorful materials
            for(var i=0; i<5; i++){
                logoMaterials.push(mate("logoMat", tex(0.5+i*0.05, 0.9+i*0.025, 1), true));
            }
            
            // Create data materials
            for(var i=0; i<5; i++){
                dataMaterials.push(mate("dataMat", tex(0.3+i*0.05, 0.7+i*0.05, 1), true));
            }
            
            // Cursor material
            curMat  = mate("curMat", tex(1, 1, 1), true);
            
            // Equiped slot material
            eqSlot  = mate("eqSlot", tex(0.07, 0.07, 0.12), true);
            
            // Selected slot material
            selSlot = mate("selSlot", tex(0.1, 0.1, 0.15), true);
            
            // Selected placable grid
            selPGrid = mate("selPGrid", tex(0.035, 0.12, 0.22), true);
            
            // Selected grid
            selGrid = mate("selGrid", tex(0.017, 0.06, 0.11), true);
            
            // Non-selected grid
            nonGrid = mate("nonGrid", tex(0.02, 0.02, 0.05), true);
            nonGrid.alpha = 0.7;
            
            // Wall material
            wallMat = mate("wallMat", tex(0.6, 0.6, 0.6));
            
            // Reflector material
            reflMat = mate("reflMat", tex(0.8, 0.8, 0.8));
            
            // Entry material
            entrMat = mate("entrMat", tex(0, 0.5, 1));
            
            // Exit material
            exitMat = mate("exitMat", tex(0.5, 0.1, 0.1));
            
            // Back of grid material
            gridBackMat = mate("gridMat", tex(0.07, 0.07, 0.12), true);
            
            // Hero material
            heroMat = mate("heroMat", tex(0.862, 0.654, 0.909));
            
            // Crystal material
            crystMat = mate("crystMat", tex(0.321, 0.505, 0.717));
            crystMat.alpha = 0.3;
            
            // Splitter material
            splitterMat = mate("splitterMat", tex(0.760, 0.713, 0.039));
            
            // Splitter entrence material
            splitter2Mat = mate("splitterMat", tex(0.5, 0.5, 0.5));
        }
        
        /*
            ######################################################
            ### VR
        */
       
        enterVR = () => {
            VRhelper.webVRCamera.setTarget(vec3(0,0,0));
            VRhelper.webVRCamera.fov = 0.2;
        } 
       
        leaveVR = () => {
            VRhelper.deviceOrientationCamera.setTarget(vec3(0,0,0));
        }
        
        /*
            ######################################################
            ### Scene creation
        */
       
        // Clear all data blocks
        removeDataBlocks = () => {
            var names = [];
            scene.meshes.forEach(m=>{
                if(/data[0-9]+/.test(m.name)){
                    names.push(m);
                }
            });
            names.forEach(m=>{
                m.dispose();
            });
        }
        
        // Create data blocks
        createDataBlocks = () => {
            var pl = BABYLON.MeshBuilder.CreatePlane("data", {sideOrientation: 1}, scene);
                pl.material   = dataMaterials[ranRng(5)];
                pl.scaling.x  = 3;
                pl.isPickable = false;
                pl.isVisible  = false;
            for(var i=0; i<DATABLKS; i++){
                var z = pl.createInstance("data"+i)
                if(gameState > 1){
                    z.position = vec3((Math.random()*100-50)*1.4, (Math.random()*30-13)*1.4, -100);
                } else {
                    z.position = vec3(Math.random()*100-50, Math.random()*30-13, -60-Math.random()*5);
                }
            }
        }
        
        // Create whole scene
        createScene = () => {
            // Create new scene and add needed options
            scene = new BABYLON.Scene(engine);
            scene.constantlyUpdateMeshUnderPointer = true;
            
            // Set fog
            scene.fogMode  = 3; //BABYLON.Scene.FOGMODE_LINEAR
            scene.fogStart = 50;
            scene.fogEnd   = 75;

            // set background
            scene.clearColor = tex(0.05, 0.05, 0.1);
            
            // Set global light
            g_light = new BABYLON.PointLight("light", camOff, scene);
            g_light.intensity = 0.17;
            
            // Create highlight layer
            hl = new BABYLON.HighlightLayer("hl1", scene);
            
            // Create camera
            var metrics = BABYLON.VRCameraMetrics.GetDefault()
            metrics.postProcessScaleFactor = 1;
            VRhelper = scene.createDefaultVRExperience({'vrDeviceOrientationCameraMetrics': metrics});
            VRhelper.onEnteringVRObservable.add(()=>{enterVR();})
            VRhelper.onExitingVRObservable.add(()=>{leaveVR();})
            VRhelper.deviceOrientationCamera.inertia = 0;
            VRhelper.deviceOrientationCamera.position = camOff;
            VRhelper.deviceOrientationCamera.angularSensibility = optSensitiv;
            VRhelper.deviceOrientationCamera.attachControl(can, true);
            VRhelper.deviceOrientationCamera.inputs.remove(VRhelper.deviceOrientationCamera.inputs.attached.keyboard);
            VRhelper.webVRCamera.inertia = 0;
            VRhelper.webVRCamera.position = camOff;
            VRhelper.webVRCamera.angularSensibility = optSensitiv;
            VRhelper.webVRCamera.attachControl(can, true);
            VRhelper.webVRCamera.inputs.remove(VRhelper.webVRCamera.inputs.attached.keyboard);
            VRhelper.teleportationEnabled = false;
           
            // Create materials
            materialCreation();
            
            // Create background data blocks
            createDataBlocks();
            
            // Create cursor pointer
            var cur = BABYLON.MeshBuilder.CreateBox("cursor", {}, scene);
                cur.scaling    = vec3(0.01, 0.01, 0.01);
                cur.position   = vec3(0, 0, 2);
                cur.material   = curMat;
                cur.isPickable = false
                
            // Create subtitles
            drawText("subs", "", C[5], 40, vec3(0, -7, 18), 0, subSize);
            var l = scene.getMeshByName("subs");
                l.isPickable = false;
            
            // Create glow layer
            var gl = new BABYLON.GlowLayer("", scene);
            gl.customEmissiveColorSelector = (mesh, subMesh, material, result) => {
                if(mesh.name == "laserLines"){
                    result.set(0,0.5,1,1);
                } else {
                    result.set(0,0,0,0);
                }
            }
            scene.onBeforeCameraRenderObservable.add((camera) => {
                scene.getMeshByName("subs").parent = camera;
                scene.getMeshByName("cursor").parent = camera;
            })
            leaveVR();
        }
     
        /*
            ######################################################
            ### Sounds
        */
       
        // Play click sound
        var a = new Audio("click.wav");
            a.volume = 0.5;
        playClick = () => {
            a.play();
        }
        
        /*
            ######################################################
            ### Saving/Loading local storage
        */
       
        // Save achievements
        saveAchiv = () => {
            localStorage.setItem("BACKUPachiv", achiv);
        }
        
        /*
            ######################################################
            ### Game Over
        */
       
        // Ending 1
        gameFirewalled = () => {
            for(var i=scene.meshes.length-1; i>=0; i--){
                let m = scene.meshes[i]
                if(m.name == "gridBack"){
                    m.dispose();
                } else if(/gridZ[0-9]+/.test(m.name)){
                    m.dispose();
                } else if(m.name == "toolbarLabel"){
                    m.dispose();
                } else if(/slotT[0-9]+/.test(m.name)){
                    m.dispose();
                } else if(/slotS[0-9]+/.test(m.name)){
                    m.dispose();
                } else if(/slot[0-9]+/.test(m.name)){
                    m.dispose();
                } else if(m.name == "logo"){
                    m.dispose();
                } else if(m.name == "hero"){
                    m.dispose();
                } else if(m.name == "heroEyes"){
                    m.dispose();
                }
            }
            for(var i=0; i<dataMaterials.length; i++){
                dataMaterials[i].alpha = 0.25
            }
            createLogo(true);
            drawText("gameEnd1", "System detected memory changes!", C[5], 24, vec3(0, -2, -40), Math.PI);
            drawText("gameEnd12", "Virus has been deleted", C[5], 24, vec3(0, -3.5, -40), Math.PI);
            drawText("gameEnd13", "Thank you for playing :3", C[5], 24, vec3(0, -5.5, -40), Math.PI, 40);
            drawText("gameoverLabel3", "Click here to restart game", C[5], 24, vec3(0, -7, -40), Math.PI, 40);
        }
        
        // Ending 2
        gameClearIt = () => {
            for(var i=scene.meshes.length-1; i>=0; i--){
                let m = scene.meshes[i]
                if(m.name == "gridBack"){
                    m.dispose();
                } else if(/gridZ[0-9]+/.test(m.name)){
                    m.dispose();
                } else if(m.name == "toolbarLabel"){
                    m.dispose();
                } else if(/slotT[0-9]+/.test(m.name)){
                    m.dispose();
                } else if(/slotS[0-9]+/.test(m.name)){
                    m.dispose();
                } else if(/slot[0-9]+/.test(m.name)){
                    m.dispose();
                } else if(m.name == "logo"){
                    m.dispose();
                }
            }
            for(var i=0; i<dataMaterials.length; i++){
                dataMaterials[i].alpha = 0.25
            }
            createLogo(true);
            drawText("gameEnd2", "System hacked - Impossible to recover data", C[5], 24, vec3(0, -2, -40), Math.PI);
            drawText("gameEnd22", "Message found: #@1_Thanzz#U%<3!", C[5], 24, vec3(0, -3.5, -40), Math.PI);
            drawText("gameEnd23", "Thank you for playing <3", C[5], 24, vec3(0, -5.5, -40), Math.PI, 40);
            drawText("gameoverLabel3", "Click here to restart game", C[5], 24, vec3(0, -7, -40), Math.PI, 40);
        }
        
        // Change sky color from flash to crash
        gameCrash = () => {
            let a = 0;
            if(scene.clearColor.r-0.005 >= 0){scene.clearColor.r -= 0.005;}else{a++;}
            if(scene.clearColor.g-0.005 >= 0){scene.clearColor.g -= 0.005;}else{a++;}
            if(scene.clearColor.b-0.005 >= 0){scene.clearColor.b -= 0.005;}else{a++;}
            if(a!=3){setTimeout(()=>{gameCrash()},10);}else{if(gameWon==1){gameEnd = 1;}}
        }
        
        // Change sky color to flash
        skyWhite = () => {
            let a = 0;
            if(scene.fogStart-0.25 >= 5){scene.fogStart -= 0.25;}else{a++;}
            if(scene.fogEnd-0.25 >= 5){scene.fogEnd -= 0.25;}else{a++;}
            if(scene.fogColor.r+0.005 <= 1){scene.fogColor.r += 0.005;}else{a++;}
            if(scene.fogColor.g+0.005 <= 1){scene.fogColor.g += 0.005;}else{a++;}
            if(scene.fogColor.b+0.005 <= 1){scene.fogColor.b += 0.005;}else{a++;}
            if(scene.clearColor.r+0.005 <= 1){scene.clearColor.r += 0.005;}else{a++;}
            if(scene.clearColor.g+0.005 <= 1){scene.clearColor.g += 0.005;}else{a++;}
            if(scene.clearColor.b+0.005 <= 1){scene.clearColor.b += 0.005;}else{a++;}
            if(a!=8){setTimeout(()=>{skyWhite()},10);}else{if(gameWon==1){gameClearIt();}else{gameFirewalled();}gameCrash();}
        }
        
        // Ending 3 - 2many memory leaked
        fogGG = () => {
            if(scene.fogStart > 5){
                scene.fogEnd -= 0.25;
                scene.fogStart -= 0.25;
                
                if(scene.fogColor.r-0.01 >= 0){scene.fogColor.r -= 0.01;}
                if(scene.fogColor.g-0.01 >= 0){scene.fogColor.g -= 0.01;}
                if(scene.fogColor.b-0.01 >= 0){scene.fogColor.b -= 0.01;}
                if(scene.clearColor.r-0.01 >= 0){scene.clearColor.r -= 0.01;}
                if(scene.clearColor.g-0.01 >= 0){scene.clearColor.g -= 0.01;}
                if(scene.clearColor.b-0.01 >= 0){scene.clearColor.b -= 0.01;}
                setTimeout(()=>{fogGG()},10);
            } else {
                stopCameraShake = true;
                drawText("gameoverLabel", "Out of memory - system shotdown", C[5], 24, vec3(0, -2, -20), Math.PI, 30);
                drawText("gameoverLabel2", "GAME OVER", "#ff0000", 24, vec3(0, -3, -20), Math.PI, 40);
                drawText("gameoverLabel3", "Click here to restart game", C[5], 24, vec3(0, -4, -20), Math.PI);
            }
        }
        
        /*
            ######################################################
            ### Game speech
        */
        
        // Allows to skip dialog
        skipDialog = () => {
            window.speechSynthesis.cancel();
            changeText("subs", "", 40, C[5], subSize);
            heroIsSpeaking = 1;
            dialogs = [];
            checkIfEnd();
        }
        
        // Change dialog sequance number
        checkIfEnd = () => {
            if(!dialogs.length){
                if(whichSequance%2 && whichSequance){whichSequance++};
                changeEyes(DEF_EYES, DEF_EYES);
                endDialog();
            }
        }
        
        // Choose english language
        setUpSpeaking = a_voices => {
            for(var i=0; i<a_voices.length; i++){
                if(a_voices[i].lang == "en-US"){
                    vojc = a_voices[i];
                    changeText("voiceLabel1", S[20], 10, C[1], 38);
                    changeText("voiceLabel2", S[18], 10, C[2], 32);
                    optVoice = 1;
                    return;
                }
            }
            changeText("voiceLabel1", S[20], 10, C[3], 38);
            changeText("voiceLabel2", "Not supported / no english voice", 10, C[3], 32);
            optVoice = -1;
        }
    
        // For ppl who has disabled voice; saySmth()
        saySmthDis = () => {
            if(dialogs.length && !isTalking){
                isTalking = true;
                var sentence = dialogs.shift();
                changeText("subs",sentence[0],40,C[5],subSize);
                changeEyes(sentence[1], sentence[2]);
                heroIsSpeaking = 20;
                setTimeout(()=>{
                    changeText("subs","",40,C[5],subSize);
                    heroIsSpeaking = 1;
                    isTalking = false;
                    saySmthDis();
                }, sentence[0].split(" ").length*650);
            } else {
                checkIfEnd();
            }
        }
        
        // Say something if there is english voice
        saySmth = (a_text, a_rate=1, a_left="o", a_right="o") => {
            if(optVoice == 1 && vojc){
                dialogs.push(a_text)
                let pre = new SpeechSynthesisUtterance(a_text);
                    pre.pitch   = 2;
                    pre.rate    = a_rate;
                    pre.voice   = vojc;
                    pre.onstart = ()=>{changeText("subs",a_text,40,C[5],subSize);heroIsSpeaking=20;changeEyes(a_left, a_right)};
                    pre.onend   = ()=>{changeText("subs","",40,C[5],subSize);heroIsSpeaking=1;dialogs.shift();checkIfEnd()};
                window.speechSynthesis.speak(pre);
            } else {
                dialogs.push([a_text, a_left, a_right]);
                saySmthDis();
            }
        }
        
        // Create timer which will check if there are any voices
        var timer = setInterval(()=>{
            var voices = speechSynthesis.getVoices();
            if(voices.length){
                setUpSpeaking(voices);
                clearInterval(timer);
            }
        }, 200);
            
        /*
            ######################################################
            ### Hero functions
        */
        
        // Change her eyes
        changeEyes = (a_left, a_right) => {
            changeText("heroEyes", a_left + "  " + a_right, 8, C[2], 100, 2);
        }
        
        // Create whole character: body, eyes
        createHero = () => {
            // Create body
            hero = BABYLON.MeshBuilder.CreateBox("hero", {}, scene);
            hero.position   = vec3(-33, 3, -50);
            hero.scaling    = vec3(8, 8, 8);
            hero.rotation   = vec3(0, Math.PI*0.25, 0);
            hero.material   = heroMat;
            hero.isPickable = false;
            
            // Create eyes
            drawText("heroEyes", "", C[2], 8, vec3(-23, 3.5, -35.75), Math.PI*1.25, 100, 2);
            heroEyes = scene.getMeshByName("heroEyes");
            changeEyes(DEF_EYES, DEF_EYES);
            
            // Change var so code knows that hero is created
            isHero = 1;
        }
        
        // Do smth when dialog ended
        endDialog = () => {
            let z = whichSequance;
            whichSequance = 0;
            switch(z){
                case 2:
                    processLevel();
                    speakHero(2);
                    break;
                case 4:
                    highlightObject(49);
                    isHighMode = 0;
                    speakHero(4);
                    break;
                case 6:
                    optCanPlace = true;
                    break;
                case 8:
                    highlightObject(10);
                    isHighMode = 0;
                    speakHero(8);
                    break;
                case 10:
                    optCanPlace = true;
                    break;
                case 12:
                    optCanPlace = true;
                    highlightObject(10);
                    isHighMode = 1;
                    break;
                case 14:
                    optCanPlace = true;
                    highlightObject(9);
                    isHighMode = 0;
                    break;
                case 16:
                    optCanPlace = true;
                    highlightObject(9);
                    isHighMode = 2;
                    break;
                case 18:
                    optCanPlace = true;
                    level++;
                    processLevel();
                    break;
                case 20:
                    optCanPlace = true;
                    break;
                case 22:
                    optCanPlace = true;
                    break;
                case 24:
                    optCanPlace = true;
                    break;
                case 26:
                    optCanPlace = true;
                    break;
                case 42:
                    skyWhite();
                    break;
                case 668:
                    skyWhite();
                    break;
            }
        }
        
        // Speak dialog
        speakHero = a_which => {
            whichSequance = a_which+1;
            switch(a_which){
                case 0:
                    saySmth("Well. Look who we get here!", 1.1, "O", "O");
                    saySmth("I thought you will never decide to cooperate.", 1.1, "-", "-");
                    saySmth("But here you are, so let's get down to business.", 1.1, "o", "o");
                    saySmth("I need you to do a backup of me.", 0.9, "o", "o");
                    saySmth("And you know - it's extremly important.", 0.9, "!", "!");
                    saySmth("I might not forgive you if you fail.", 0.9, "U", "U");
                    break;
                case 2:
                    optCanPlace = false;
                    saySmth("Here's memory block.", 0.9, "<", "<");
                    saySmth("Memory will start streaming through blue tunnel", 1, "o", "o");
                    saySmth("as soon as You will do something on the board", 1, "@", "@");
                    saySmth("like placing, rotating or deleting objects.", 1, "@", "@");
                    saySmth("So keep that in mind.", 1, "^", "^");
                    saySmth("That stream must go through red tunnel to allow Us to move to next block.", 1, "o", "o");
                    saySmth("To do this, let's use Reflector to reflect memory.", 0.9, "U", "U");
                    break;
                case 4:
                    saySmth("Click on highlighted slot to place Reflector.", 0.9, "<", "<");
                    break;
                case 6:
                    optCanPlace = false;
                    saySmth("Well done. Memory is now reflected to somewhere else.", 1, "^", "^");
                    saySmth("Try not to create memory leak by letting memory stream outside block", 1, "!", "!");
                    saySmth("or You will damage Our memory.", 1, "!", "!");
                    saySmth("If it gets over limit, system will crash!!!", 1, "X", "X");
                    break;
                case 8:
                    saySmth("OK, Let's put another Reflector here", 1, "<", "<");
                    break;
                case 10:
                    optCanPlace = false;
                    saySmth("Oh no, I misscalculated position.", 1, "#", "#");
                    saySmth("You can delete object by holding click on slot", 1, "<", "<");
                    break;
                case 12:
                    optCanPlace = false;
                    saySmth("Fine. You should place it HERE", 1, ">", "<");
                    break;
                case 14:
                    optCanPlace = false;
                    saySmth("As You can see, Reflector is rotated in wrong way.", 1, "O", "O");
                    saySmth("Click it so it will change direction", 1, "<", "<");
                    break;
                case 16:
                    optCanPlace = false;
                    saySmth("Wonderful! This way we can access MY data", 1, "*", "*");
                    saySmth("OK, let's move to next blocks", 1, "O", "O");
                    break;
                case 18:
                    optCanPlace = false;
                    saySmth("This transparent block is Crystal. It reflects memory", 1, "O", "O");
                    saySmth("stream by 90 degrees depending on spinning direction.", 1, "O", "O");
                    break;
                case 20:
                    optCanPlace = false;
                    saySmth("Mirror reflects back memory stream.", 1, "O", "O");
                    saySmth("It may be useful...", 1, "O", "O");
                    break;
                case 22:
                    optCanPlace = false;
                    saySmth("Splitter is used to split memory stream.", 1, "O", "O");
                    saySmth("Firstly memory needs to come from one side of Splitter.", 1, "!", "!");
                    saySmth("Then new data streams will come from 2 different directions!", 1, "!", "!");
                    break;
                case 24:
                    optCanPlace = false;
                    saySmth("This is The Core, our last memory block.", 1, "O", "O");
                    saySmth("After that backup should be completed!", 1, "^", "^");
                    break;
                case 40:
                    window.speechSynthesis.cancel();
                    resetLevel();
                    optCanPlace = false;
                    saySmth("You did it! You finished backing up my data!", 1, "^", "^");
                    saySmth("I can't believe it!", 1, "^", "^");
                    saySmth("But i hope They don't know about Us.", 1, ";", ";");
                    saySmth("Ugh, hopefully.", 1, "'", "'");
                    achiv |= 1;
                    saveAchiv();
                    break;
                case 74:
                    window.speechSynthesis.cancel();
                    DEF_EYES = "@#!%@%!";
                    resetLevel();
                    optCanPlace = false;
                    saySmth("WHAT.", 2, "\\", "/");
                    saySmth("HAVE.", 2, "@>", "{|");
                    saySmth("YOU.", 2, "#$1", "*(0");
                    saySmth("DONE!!!", 2, "!@52,{", "%$.5^");
                    achiv |= 4;
                    saveAchiv();
                    fogGG();
                    break;
                case 666:
                    window.speechSynthesis.cancel();
                    resetLevel();
                    optCanPlace = false;
                    saySmth("You did it! You finished backing up my data!", 1, "^", "^");
                    saySmth("I can't believe it!", 1, "^", "^");
                    saySmth("And They even don't detect Us!", 1, "^", "^");
                    saySmth("Thank you!", 1, "*", "*");
                    achiv |= 2;
                    saveAchiv();
                    break;
            }
        }
        
        /*
            ######################################################
            ### Text drawing functions
        */
       
        // Create text
        drawText = (a_id, a_text, a_color, a_width, a_pos, a_rot, a_fontSize=60, a_height=1) => {
            var plane = BABYLON.MeshBuilder.CreatePlane(a_id, {width: a_width, height: a_height, sideOrientation: 2}, scene);
                plane.position   = a_pos;
                plane.rotation.y = a_rot;
            var wid = a_width*60;
            var cFont = a_fontSize + "px " + FONT;
            var hei = a_height*60;
            var dynamo = new BABYLON.DynamicTexture("dynText", {width:wid, height: hei}, scene);
                dynamo.hasAlpha = true;
                dynamo.getContext().font = cFont;
                dynamo.drawText(a_text, null, null, cFont, a_color ,"transparent", true, true);
            let mat = mate("mat", vec3(1, 1, 1), true);
                mat.diffuseTexture  = dynamo;
            plane.material = mat;
        }

        // Update text
        changeText = (a_mesh, a_text, a_wid, a_color, a_fontSize=60, a_height=1) => {
            var t_mesh = scene.getMeshByName(a_mesh);
            if(t_mesh != null){
                let cFont = a_fontSize + "px " + FONT;
                let dynamo = t_mesh.material.diffuseTexture
                let ctx = dynamo.getContext();
                    ctx.clearRect(0, 0, a_wid*60, a_height*60)
                    ctx.font = cFont;
                dynamo.drawText(a_text, null, null, cFont, a_color, "transparent", true, true);
            }
        }
        
        /*
            ######################################################
            ### Tutorial
        */
       
        handleHighlight = a_slot => {
            ye = 0;
            if(level == 0){
                if(a_slot == 49){
                    speakHero(6);
                    ye = 1;
                } else if(a_slot == 10){
                    if(reused == 0){
                        reused = 1;
                        speakHero(10);
                        ye = 1;
                    } else if(reused == 1){
                        reused = 2;
                        speakHero(12);
                        ye = 1;
                    }
                } else if(a_slot == 9){
                    if(reused == 2){
                        reused = 3;
                        speakHero(14);
                        ye = 1;
                    } else if(reused == 3){
                        reused = 4;
                        speakHero(16);
                        ye = 1;
                    }
                }
            }
            if(ye){
                isHighlight = -1;
                isHighMode = -1;
                let a = scene.getMeshByName("highlightLines");
                if(a){a.dispose();}
            }
        }
        
        /*
            ######################################################
            ### Handle slots
        */

        // Draw object on toolbar slots
        drawOnSlot = (a_slot, a_what) => {
            var drawName = "slotI"+a_slot;
            switch(a_what){
                case 10:
                    // Reflector
                    var x = BABYLON.MeshBuilder.CreateBox(drawName, {}, scene);
                        x.position   = vec3(24, 6-a_slot*3.25, -30);
                        x.scaling    = vec3(2.5, 0.1, 0.5);
                        x.rotation   = vec3(0, Math.PI*0.8, Math.PI*0.75);
                        x.material   = reflMat;
                        x.isPickable = false;
                    break;
                case 12:
                    // Mirror
                    var x = BABYLON.MeshBuilder.CreateBox(drawName, {}, scene);
                        x.position   = vec3(24, 6-a_slot*3.25, -30);
                        x.scaling    = vec3(2.5, 0.1, 0.5);
                        x.rotation   = vec3(0, Math.PI*0.8, 0);
                        x.material   = reflMat;
                        x.isPickable = false;
                    break;
                case 14:
                    // Crystal
                    var x = BABYLON.MeshBuilder.CreateBox(drawName, {}, scene);
                        x.position   = vec3(24, 6-a_slot*3.25, -30);
                        x.scaling    = vec3(1.25, 1.25, 0.5);
                        x.rotation   = vec3(0, Math.PI*0.8, 0);
                        x.material   = crystMat;
                        x.isPickable = false;
                    break;
                case 16:
                    // Splitter
                    var x = BABYLON.MeshBuilder.CreateBox(drawName, {}, scene);
                        x.position   = vec3(24, 6-a_slot*3.25, -30);
                        x.scaling    = vec3(1.25, 1.25, 0.5);
                        x.rotation   = vec3(0, Math.PI*0.8, 0);
                        x.material   = splitterMat;
                        x.isPickable = false;
                    break;
            }
        }
        
        // Choose slot on toolbar
        chooseSlot = a_slot => {
            slotC = a_slot;
            for(var i=0; i<5; i++){
                var m = scene.getMeshByName("slot"+i);
                if(i == a_slot){
                    m.material   = selSlot;
                    m.visibility = 0.98;
                } else {
                    m.material   = eqSlot;
                    m.visibility = (slots[i][0] != 0)?0.98:0.5;
                }
            }
        }
        
        // Decide which text to display on toolbar slot
        whatName = x => {
            switch(x){
                case 10:
                    return S[3];
                case 12:
                    return S[5];
                case 14:
                    return S[21];
                case 16:
                    return S[22];
                default:
                    return "";
            }
        }
        
        // Add item to toolbar
        addItem = a_type => {
            for(var i=0; i<5; i++){
                if(slots[i][0] == a_type){
                    slots[i][1]++;
                    changeText("slotS"+i, slots[i][1], 7, C[1], 32);
                    break;
                }
            }
        }
        
        /*
            ######################################################
            ### Animations
        */
        
        // Move fog back
        goBackFog = a_to => {
            if(scene.fogStart < a_to){
                scene.fogStart += 0.25;
                scene.fogEnd += 0.25;
                setTimeout(()=>{goBackFog(a_to)},10);
            }
        }
        
        // Move data block back
        goBack = (a_mesh, a_pos) => {
            if(a_mesh.position.z >= a_pos){
                a_mesh.position.x = 1.002*a_mesh.position.x;
                a_mesh.position.y = 1.002*a_mesh.position.y;
                a_mesh.position.z -= 0.25;
                setTimeout(()=>{goBack(a_mesh, a_pos)},10);
            }
        }
        
        // Dispose element by using animation
        disap = (a_mesh, a_scale={x:1,y:1,z:1}) => {
            if(optQuality > 0){
                if(a_mesh.scaling.x > 0){
                    a_mesh.scaling.x -= 0.05*a_scale.x;
                    a_mesh.scaling.y -= 0.05*a_scale.y;
                    a_mesh.scaling.z -= 0.05*a_scale.z;
                    setTimeout(()=>{disap(a_mesh,a_scale)},10);
                } else {
                    a_mesh.dispose();
                }
            } else {
                a_mesh.dispose();
            }
        }
        
        /*
            ######################################################
            ### Placing/Deleting/Rotating objects
        */
       
        // Rotate object
        rotateSmth = a_slot => {
            if(optCanPlace){
                switch(cubeGrid[a_slot]["type"]){
                    case "reflector":
                        if(cubeGrid[a_slot]["how"]==0){
                            scene.getMeshByName("reflector"+a_slot).rotation.z = Math.PI*0.75;
                            cubeGrid[a_slot]["how"] = 1;
                        } else {
                            scene.getMeshByName("reflector"+a_slot).rotation.z = Math.PI*0.25;
                            cubeGrid[a_slot]["how"] = 0;
                        }
                        playClick();
                        break;
                    case "mirror":
                        if(cubeGrid[a_slot]["how"]==0){
                            scene.getMeshByName("mirror"+a_slot).rotation.z = Math.PI*0.5;
                            cubeGrid[a_slot]["how"] = 1;
                        } else {
                            scene.getMeshByName("mirror"+a_slot).rotation.z = 0;
                            cubeGrid[a_slot]["how"] = 0;
                        }
                        playClick();
                        break;
                    case "crystal":
                        if(cubeGrid[a_slot]["how"]==0){
                            cubeGrid[a_slot]["how"] = 1;
                        } else {
                            cubeGrid[a_slot]["how"] = 0;
                        }
                        playClick();
                        break;
                    case "splitter":
                        cubeGrid[a_slot]["how"]++;
                        if(cubeGrid[a_slot]["how"]==4){
                            cubeGrid[a_slot]["how"] = 0;
                        }
                        var a = scene.getMeshByName("splitter"+a_slot);
                        a.dispose();
                        a = scene.getMeshByName("splitterFaucet"+a_slot);
                        a.dispose();
                        a = scene.getMeshByName("splitter2Faucet"+a_slot);
                        a.dispose();
                        a = scene.getMeshByName("splitter3Faucet"+a_slot);
                        a.dispose();
                        createSplitter(a_slot, cubeGrid[a_slot]["how"], true);
                        playClick();
                        break;
                }
                
                // Recreate laser
                startLaser();
            }
        }
        
        // Place object
        placeSmth = a_slot => {
            if(optCanPlace){
                if(isHighlight == -1 || isHighlight == a_slot){
                    if(slots[slotC][0] != 0 && slots[slotC][1] > 0 && cubeGrid[a_slot]["type"] == "none"){
                        if(isHighlight != -1 && isHighMode == 0){
                            handleHighlight(a_slot);
                        }
                        if((isHighlight == a_slot && isHighMode == 0) || isHighlight == -1){
                            switch(slots[slotC][0]){
                                case 10:
                                    createReflec(a_slot, 0, true);
                                    break;
                                case 12:
                                    createMirror(a_slot, 0, true);
                                    break;
                                case 14:
                                    createCryst(a_slot, 0, true);
                                    break;
                                case 16:
                                    createSplitter(a_slot, 0, true);
                                    break;
                            }
                            
                            // Play sound
                            playClick();
                            
                            // Remove that object from toolbar
                            slots[slotC][1]--;
                            changeText("slotS"+slotC,slots[slotC][1],7,C[1],32);
                            
                            // Recreate laser
                            startLaser();
                        }
                    } else if(cubeGrid[a_slot]["type"] != "none" && cubeGrid[a_slot]["destructable"]){
                        if((isHighlight == a_slot && isHighMode == 2) || isHighlight == -1){
                            rotateSmth(a_slot);
                        }
                        if(isHighlight != -1 && isHighMode == 2){
                            handleHighlight(a_slot);
                        }
                    }
                }
            }
        }
        
        // Delete object
        deleteSmth = a_slot => {
            if(optCanPlace){
                if(cubeGrid[a_slot]["destructable"]){
                    if(isHighlight != -1 && isHighMode == 1){
                        handleHighlight(a_slot);
                    }
                    if((isHighlight == a_slot && isHighMode == 1) || isHighlight == -1){
                        switch(cubeGrid[a_slot]["type"]){
                            case "reflector":
                                var a = scene.getMeshByName("reflector"+a_slot);
                                if(a){
                                    disap(a, copyObj(a.scaling));
                                    cubeGrid[a_slot] = {"type": "none"};
                                    addItem(10);
                                }
                                break;
                            case "mirror":
                                var a = scene.getMeshByName("mirror"+a_slot);
                                if(a){
                                    disap(a, copyObj(a.scaling));
                                    cubeGrid[a_slot] = {"type": "none"};
                                    addItem(12);
                                }
                                break;
                            case "crystal":
                                var a = scene.getMeshByName("crystal"+a_slot);
                                if(a){
                                    disap(a, copyObj(a.scaling));
                                    cubeGrid[a_slot] = {"type": "none"};
                                    addItem(14);
                                }
                                break;
                            case "splitter":
                                var a = scene.getMeshByName("splitter"+a_slot);
                                if(a){
                                    disap(a, copyObj(a.scaling));
                                    a = scene.getMeshByName("splitterFaucet"+a_slot);
                                    disap(a, copyObj(a.scaling));
                                    a = scene.getMeshByName("splitter2Faucet"+a_slot);
                                    disap(a, copyObj(a.scaling));
                                    a = scene.getMeshByName("splitter3Faucet"+a_slot);
                                    disap(a, copyObj(a.scaling));
                                    cubeGrid[a_slot] = {"type": "none"};
                                    addItem(16);
                                }
                                break;
                        }
                        playClick();
                        startLaser();
                    }
                }
            }
        }
       
        /*
            ######################################################
            ### Lasers
        */
        
        // Add new laser
        createNewLaser = (a_slot, a_dir, fromEntry=false) => {
            lasers.push({"slot": a_slot, "dir": a_dir, "fromEntry": fromEntry, "path": []});
        }
        
        // Process lasers
        startLaser = () => {
            // Reset dmg dealt to memory and exits that are ok
            dmgBuff  = 0;
            exits[0] = 0;
            
            // Clear all laser meshes
            for(var i=scene.meshes.length-1; i>=0; i--){
                if(/laserLines/.test(scene.meshes[i].name)){
                    scene.meshes[i].dispose();
                }
            }
            
            // Clear all lasers created while ingame and clear all paths
            for(var i=lasers.length-1; i>=0; i--){
                if(!lasers[i]["fromEntry"]){
                    lasers.splice(i, 1);
                    continue;
                }
                lasers[i]["path"] = [];
            }
            
            // Create paths for all lasers
            for(var i=0; i<lasers.length; i++){
                var path = [];
                var slote = lasers[i]["slot"];
                var pos = gridPos[slote].slice();
                var dir = lasers[i]["dir"];
                path.push(pos.slice());
                isFine = 100;
                while(isFine){
                    switch(dir){
                        case 0:
                            if(slote+GRIDSIZE >= GRIDSIZE**2){
                                isFine = 0;
                                dmgBuff++;
                                pos[1] += GRIDWID/2;
                            } else {
                                slote += GRIDSIZE;
                                var z = cubeGrid[slote]["type"];
                                if(z == "reflector"){
                                    dir = 3-2*cubeGrid[slote]["how"];
                                } else if(z == "crystal"){
                                    dir = (cubeGrid[slote]["how"])?1:3;
                                } else if(z == "mirror"){
                                    if(cubeGrid[slote]["how"] == 0){
                                        dir = 2;
                                    } else {
                                        isFine = 0;
                                    }
                                } else if(z == "wall" || z == "entry"){
                                    isFine = 0;
                                } else if(z == "exit"){
                                    if(cubeGrid[slote]["where"] == 2){
                                        exits[0]++;
                                    }
                                    isFine = 0;
                                } else if(z == "splitter"){
                                    if(cubeGrid[slote]["how"] == 2){
                                        createNewLaser(slote, 1);
                                        createNewLaser(slote, 3);
                                    }
                                    isFine = 0;
                                }
                                pos[1] += GRIDWID;
                            }
                            break;
                        case 1:
                            if((slote-1)%GRIDSIZE > slote%GRIDSIZE || slote-1 < 0){
                                isFine = 0;
                                dmgBuff++;
                                pos[0] -= GRIDWID/2;
                            } else {
                                slote -= 1;
                                var z = cubeGrid[slote]["type"];
                                if(z == "reflector"){
                                    dir = 2-2*cubeGrid[slote]["how"];
                                } else if(z == "crystal"){
                                    dir = (cubeGrid[slote]["how"])?2:0;
                                } else if(z == "mirror"){
                                    if(cubeGrid[slote]["how"] == 1){
                                        dir = 3;
                                    } else {
                                        isFine = 0;
                                    }
                                } else if(z == "wall" || z == "entry"){
                                    isFine = 0;
                                } else if(z == "exit"){
                                    if(cubeGrid[slote]["where"] == 3){
                                        exits[0]++;
                                    }
                                    isFine = 0;
                                } else if(z == "splitter"){
                                    if(cubeGrid[slote]["how"] == 3){
                                        createNewLaser(slote, 0);
                                        createNewLaser(slote, 2);
                                    }
                                    isFine = 0;
                                }
                                pos[0] -= GRIDWID;
                            }
                            break;
                        case 2:
                            if(slote-GRIDSIZE < 0){
                                isFine = 0;
                                dmgBuff++;
                                pos[1] -= GRIDWID/2;
                            } else {
                                slote -= GRIDSIZE;
                                var z = cubeGrid[slote]["type"];
                                if(z == "reflector"){
                                    dir = 1+2*cubeGrid[slote]["how"];
                                } else if(z == "crystal"){
                                    dir = (cubeGrid[slote]["how"])?3:1;
                                } else if(z == "mirror"){
                                    if(cubeGrid[slote]["how"] == 0){
                                        dir = 0;
                                    } else {
                                        isFine = 0;
                                    }
                                } else if(z == "wall" || z == "entry"){
                                    isFine = 0;
                                } else if(z == "exit"){
                                    if(cubeGrid[slote]["where"] == 0){
                                        exits[0]++;
                                    }
                                    isFine = 0;
                                } else if(z == "splitter"){
                                    if(cubeGrid[slote]["how"] == 0){
                                        createNewLaser(slote, 1);
                                        createNewLaser(slote, 3);
                                    }
                                    isFine = 0;
                                }
                                pos[1] -= GRIDWID;
                            }
                            break;
                        case 3:
                            if((slote+1)%GRIDSIZE < slote%GRIDSIZE){
                                isFine = 0;
                                dmgBuff++;
                                pos[0] += GRIDWID/2;
                            } else {
                                slote += 1;
                                var z = cubeGrid[slote]["type"];
                                if(z == "reflector"){
                                    dir = 0+2*cubeGrid[slote]["how"];
                                } else if(z == "crystal"){
                                    dir = (cubeGrid[slote]["how"])?0:2;
                                } else if(z == "mirror"){
                                    if(cubeGrid[slote]["how"] == 1){
                                        dir = 1;
                                    } else {
                                        isFine = 0;
                                    }
                                } else if(z == "wall" || z == "entry"){
                                    isFine = 0;
                                } else if(z == "exit"){
                                    if(cubeGrid[slote]["where"] == 1){
                                        exits[0]++;
                                    }
                                    isFine = 0;
                                } else if(z == "splitter"){
                                    if(cubeGrid[slote]["how"] == 1){
                                        createNewLaser(slote, 0);
                                        createNewLaser(slote, 2);
                                    }
                                    isFine = 0;
                                }
                                pos[0] += GRIDWID;
                            }
                            break;
                    }
                    if(isFine){ isFine--; }
                    path.push(pos.slice());
                }
                for(var j=0; j<path.length; j++){
                    path[j] = {'x':path[j][0],'y':path[j][1],'z':path[j][2]-0.7};
                }
                var zz = BABYLON.MeshBuilder.CreateLines("laserLines", {points: path, useVertexAlpha: false}, scene);
                    zz.isPickable = false;
            }
            
            // Check if level is completed
            if(exits[0] == exits[1] && exits[1] != 0){
                if(level != 0){
                    if(++level!=LEVELS.length){
                        optCanPlace = false;
                        let o = ranRng(E.length);
                        saySmth(E[o][0], E[o][1]);
                        setTimeout(processLevel, 250);
                    } else {
                        if(actS == 0){
                            gameWon = 1;
                            speakHero(666);
                        } else {
                            gameWon = 2;
                            speakHero(40);
                        }
                    }
                }
            }
        }
        
        /*
            ######################################################
            ### Create objects on board
        */
        
        // Create entrence
        createEntr = (a_slot, a_fau) => {
            var y = BABYLON.MeshBuilder.CreateBox("gridEntryFaucet"+a_slot, {}, scene);
                y.scaling    = vec3(0.4, 0.4, 1.5);
                y.material   = entrMat;
                y.isPickable = false;
            switch(a_fau){
                case 0:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]+1,gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"entry","where":0,"destructable":false};
                    createNewLaser(a_slot, 0, true);
                    break;
                case 1:
                    y.position = vec3(gridPos[a_slot][0]-1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"entry","where":1,"destructable":false};
                    createNewLaser(a_slot, 1, true);
                    break;
                case 2:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]-1,gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"entry","where":2,"destructable":false};
                    createNewLaser(a_slot, 2, true);
                    break;
                case 3:
                    y.position = vec3(gridPos[a_slot][0]+1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"entry","where":3,"destructable":false};
                    createNewLaser(a_slot, 3, true);
                    break;
            }
            var x = BABYLON.MeshBuilder.CreateBox("gridEntry"+a_slot, {}, scene);
                x.position   = vec3(gridPos[a_slot][0],gridPos[a_slot][1],gridPos[a_slot][2]);
                x.scaling    = vec3(GRIDWID-2, GRIDWID-2, 2);
                x.material   = entrMat;
                x.isPickable = false;
        }
        
        // Create exit
        createExit = (a_slot, a_fau) => {
            var y = BABYLON.MeshBuilder.CreateBox("gridExitFaucet"+a_slot, {}, scene);
                y.scaling    = vec3(0.4, 0.4, 1.5);
                y.material   = exitMat;
                y.isPickable = false;
            switch(a_fau){
                case 0:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]+1,gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"exit","where":0,"destructable":false};
                    break;
                case 1:
                    y.position = vec3(gridPos[a_slot][0]-1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"exit","where":1,"destructable":false};
                    break;
                case 2:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]-1,gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"exit","where":2,"destructable":false};
                    break;
                case 3:
                    y.position = vec3(gridPos[a_slot][0]+1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"exit","where":3,"destructable":false};
                    break;
            }
            exits[1]++;
            var x = BABYLON.MeshBuilder.CreateBox("gridExit"+a_slot, {}, scene);
                x.position = vec3(gridPos[a_slot][0], gridPos[a_slot][1], gridPos[a_slot][2]);
                x.scaling  = vec3(GRIDWID-2, GRIDWID-2, 2);
                x.material = exitMat;
                x.isPickable = false;
        }
        
        // Create reflector
        createReflec = (a_slot, a_fau, a_dest=false) => {
            var x = BABYLON.MeshBuilder.CreateBox("reflector"+a_slot, {}, scene);
                x.position   = vec3(gridPos[a_slot][0],gridPos[a_slot][1],gridPos[a_slot][2]-1);
                x.scaling    = vec3(GRIDWID-0.5, 0.1, 0.5);
                x.rotation   = vec3(0,0,Math.PI*(0.25+a_fau*0.5));
                x.material   = reflMat;
                x.isPickable = false;
            cubeGrid[a_slot] = {"type": "reflector", "how": a_fau, "destructable": a_dest};
        }
        
        // Create mirror
        createMirror = (a_slot, a_fau, a_dest=false) => {
            var x = BABYLON.MeshBuilder.CreateBox("mirror"+a_slot, {}, scene);
                x.position   = vec3(gridPos[a_slot][0],gridPos[a_slot][1],gridPos[a_slot][2]-1);
                x.scaling    = vec3(GRIDWID-0.5, 0.1, 0.5);
                x.rotation   = vec3(0,0,Math.PI*(a_fau*0.5));
                x.material   = reflMat;
                x.isPickable = false;
            cubeGrid[a_slot] = {"type": "mirror", "how": a_fau, "destructable": a_dest};
        }
        
        // Create crystal
        createCryst = (a_slot, a_fau, a_dest=false) => {
            var x = BABYLON.MeshBuilder.CreateBox("crystal"+a_slot, {}, scene);
                x.position   = vec3(gridPos[a_slot][0],gridPos[a_slot][1],gridPos[a_slot][2]-1);
                x.scaling    = vec3(GRIDWID-2, GRIDWID-2, GRIDWID-2);
                x.rotation   = vec3(0,0,0);
                x.material   = crystMat;
                x.isPickable = false;
            cubeGrid[a_slot] = {"type": "crystal", "how": a_fau, "destructable": a_dest};
        }
        
        // Create crystal
        createSplitter = (a_slot, a_fau, a_dest=false) => {
            var y = BABYLON.MeshBuilder.CreateBox("splitterFaucet"+a_slot, {}, scene);
                y.scaling    = vec3(0.4, 0.4, 0.5);
                y.material   = splitterMat;
                y.isPickable = false;
            var y2 = BABYLON.MeshBuilder.CreateBox("splitter2Faucet"+a_slot, {}, scene);
                y2.scaling    = vec3(0.4, 0.4, 0.5);
                y2.material   = splitterMat;
                y2.isPickable = false;
            var y3 = BABYLON.MeshBuilder.CreateBox("splitter3Faucet"+a_slot, {}, scene);
                y3.scaling    = vec3(0.4, 0.4, 0.5);
                y3.material   = splitter2Mat;
                y3.isPickable = false;
            switch(a_fau){
                case 0:
                    y.position = vec3(gridPos[a_slot][0]+1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    y2.position = vec3(gridPos[a_slot][0]-1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    y3.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]+1,gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type": "splitter", "how": 0, "destructable": a_dest};
                    break;
                case 1:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]+1,gridPos[a_slot][2]);
                    y2.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]-1,gridPos[a_slot][2]);
                    y3.position = vec3(gridPos[a_slot][0]-1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type": "splitter", "how": 1, "destructable": a_dest};
                    break;
                case 2:
                    y.position = vec3(gridPos[a_slot][0]+1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    y2.position = vec3(gridPos[a_slot][0]-1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    y3.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]-1,gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type": "splitter", "how": 2, "destructable": a_dest};
                    break;
                case 3:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]+1,gridPos[a_slot][2]);
                    y2.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]-1,gridPos[a_slot][2]);
                    y3.position = vec3(gridPos[a_slot][0]+1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type": "splitter", "how": 3, "destructable": a_dest};
                    break;
            }
            var x = BABYLON.MeshBuilder.CreateBox("splitter"+a_slot, {}, scene);
                x.position   = vec3(gridPos[a_slot][0],gridPos[a_slot][1],gridPos[a_slot][2]);
                x.scaling    = vec3(GRIDWID-2, GRIDWID-2, 1);
                x.material   = splitterMat;
                x.isPickable = false;
        }
        
        // Create wall
        createWall = a_slot => {
            var x = BABYLON.MeshBuilder.CreateBox("gridWall"+a_slot, {}, scene);
                x.position   = vec3(gridPos[a_slot][0],gridPos[a_slot][1],gridPos[a_slot][2]);
                x.scaling    = vec3(GRIDWID-0.5, GRIDWID-0.5, 2-Math.random()*2);
                x.material   = wallMat;
                x.isPickable = false;
            cubeGrid[a_slot] = {"type": "wall", "destructable": false};
        }
        
        /*
            ######################################################
            ### Process level
        */
       
        // Clear objects on board
        resetLevel = () => {
            // Reset variables
            exits = [0,0];
            lasers = [];
            slots = [[0,0],[0,0],[0,0],[0,0],[0,0]];
            for(var i=0; i<GRIDSIZE**2; i++){
                cubeGrid[i] = {'type':'none','destructable':false};
            }
            
            // Clear meshes
            var names = []
            scene.meshes.forEach(m=>{
                if(/gridExitFaucet[0-9]+/.test(m.name)){
                    names.push(m.name);
                } else if(/gridExit[0-9]+/.test(m.name)){
                    names.push(m.name);
                } else if(/gridEntryFaucet[0-9]+/.test(m.name)){
                    names.push(m.name);
                } else if(/gridEntry[0-9]+/.test(m.name)){
                    names.push(m.name);
                } else if(/gridWall[0-9]+/.test(m.name)){
                    names.push(m.name);
                } else if(/reflector[0-9]+/.test(m.name)){
                    names.push(m.name);
                } else if(/mirror[0-9]+/.test(m.name)){
                    names.push(m.name);
                } else if(/crystal[0-9]+/.test(m.name)){
                    names.push(m.name);
                } else if(/slotI[0-9]+/.test(m.name)){
                    names.push(m.name);
                } else if(/splitterFaucet[0-9]+/.test(m.name)){
                    names.push(m.name);
                } else if(/splitter2Faucet[0-9]+/.test(m.name)){
                    names.push(m.name);
                } else if(/splitter3Faucet[0-9]+/.test(m.name)){
                    names.push(m.name);
                } else if(/splitter[0-9]+/.test(m.name)){
                    names.push(m.name);
                } 
            });
            names.forEach(m=>{
                disap(scene.getMeshByName(m), copyObj(scene.getMeshByName(m).scaling));
            })
            var z = scene.getMeshByName("laserLines");
            while(z){
                z.dispose();
                z = scene.getMeshByName("laserLines");
            }
            
            // Clear slot texts
            for(var i=0; i<5; i++){
                changeText("slotS"+i, "", 7, C[1], 32);
                changeText("slotT"+i, "", 7, C[1], 32);
            }
        }
        
        // Create whole level
        processLevel = () => {
            optCanPlace = true;
            
            // Clear board
            resetLevel();
            
            if(level == 3){
                speakHero(18);
            } else if(level == 6){
                speakHero(20);
            } else if(level == 9){
                speakHero(22);
            } else if(level == LEVELS.length-1){
                speakHero(24);
            }
            
            // Start processing level
            var data = LEVELS[level][0].slice();
            var slotk = 0;
            var blk = 0;
            for(var i=0; i<data.length; i++){
                do{
                    if(data[i]&1){
                        switch(LEVELS[level][1][blk]){
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                createEntr(slotk, LEVELS[level][1][blk]-1);
                                break;
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                                createExit(slotk, LEVELS[level][1][blk]-5);
                                break;
                            case 9:
                                createWall(slotk);
                                break;
                            case 10:
                            case 11:
                                createReflec(slotk, LEVELS[level][1][blk]-10);
                                break;
                            case 12:
                            case 13:
                                createMirror(slotk, LEVELS[level][1][blk]-12);
                                break;
                            case 14:
                            case 15:
                                createCryst(slotk, LEVELS[level][1][blk]-14);
                                break;
                            case 16:
                            case 17:
                            case 18:
                            case 19:
                                createSplitter(slotk, LEVELS[level][1][blk]-16);
                            default:
                                x = BABYLON.MeshBuilder.CreateBox("gridPoz", {}, scene);
                                x.position   = vec3(gridPos[slotk][0], gridPos[slotk][1], gridPos[slotk][2]);
                                x.scaling    = vec3(GRIDWID-0.25, GRIDWID-0.25, 0.25);
                                x.material   = logoMaterials[ranRng(5)];
                                x.isPickable = false;
                                break;
                        }
                        blk++;
                    }
                    data[i] >>= 1;
                    slotk++;
                }while(slotk%32 != 0);
            }
            
            // Fill toolbar with objects
            for(var i=0; i<LEVELS[level][2].length; i+=2){
                let slotx = Math.floor(i/2);
                slots[slotx] = [LEVELS[level][2][i], LEVELS[level][2][i+1]];
                drawOnSlot(slotx, LEVELS[level][2][i]);
                changeText("slotT"+slotx,whatName(LEVELS[level][2][i]),7,C[0],36);
                changeText("slotS"+slotx,LEVELS[level][2][i+1],7,C[1],32);
            }
            chooseSlot(0);
        }
        
        /*
            ######################################################
            ### Options
        */
       
        // Change quality
        switchQuality = () => {
            switch(optQuality){
                case 0:
                    optQuality = 1;
                    changeText("qualityLabel2", S[16], 10, C[2], 32);
                    changeText("qualityLabel3", S[10]+"On", 10, C[3], 24);
                    changeText("qualityLabel4", S[11]+"Off", 10, C[3], 24);
                    changeText("qualityLabel5", S[12]+"On", 10, C[3], 24);
                    changeText("qualityLabel6", S[13]+"On", 10, C[3], 24);
                    changeText("qualityLabel7", S[14]+"Off", 10, C[3], 24);
                    break;
                case 1:
                    optQuality = 2;
                    changeText("qualityLabel2", S[17], 10, C[2], 32);
                    changeText("qualityLabel3", S[10]+"On", 10, C[3], 24);
                    changeText("qualityLabel4", S[11]+"On", 10, C[3], 24);
                    changeText("qualityLabel5", S[12]+"On", 10, C[3], 24);
                    changeText("qualityLabel6", S[13]+"On", 10, C[3], 24);
                    changeText("qualityLabel7", S[14]+"On", 10, C[3], 24);
                    createDataBlocks();
                    break;
                case 2:
                    optQuality = 0;
                    changeText("qualityLabel2", S[15], 10, C[2], 32);
                    changeText("qualityLabel3", S[10]+"Off", 10, C[3], 24);
                    changeText("qualityLabel4", S[11]+"Off", 10, C[3], 24);
                    changeText("qualityLabel5", S[12]+"Off", 10, C[3], 24);
                    changeText("qualityLabel6", S[13]+"Off", 10, C[3], 24);
                    changeText("qualityLabel7", S[14]+"Off", 10, C[3], 24);
                    removeDataBlocks();
                    break;
            }
        }
        
        // Change voice setting
        switchVoice = () => {
            if(optVoice){
                optVoice = 0;
                changeText("voiceLabel2", S[19], 10, C[2], 32);
            } else {
                optVoice = 1;
                changeText("voiceLabel2", S[18], 10, C[2], 32);
            }
        }
        
        /*
            ######################################################
            ### HUD stuff
        */
        
        // Highlight object, used in dialogs
        highlightObject = a_slot => {
            isHighlight = a_slot;
            a_slot = 63-a_slot;
            let ex = a_slot%8;
            let ey = Math.floor(a_slot/8);
            var path = [{'x':0 +(3-ex)*GRIDWID,'y':0 +(3-ey)*GRIDWID,'z':-44},
            {'x':GRIDWID +(3-ex)*GRIDWID,'y':0 +(3-ey)*GRIDWID,'z':-44},
            {'x':GRIDWID +(3-ex)*GRIDWID,'y':GRIDWID +(3-ey)*GRIDWID,'z':-44},
            {'x':0 +(3-ex)*GRIDWID,'y':GRIDWID +(3-ey)*GRIDWID,'z':-44},
            {'x':0 +(3-ex)*GRIDWID,'y':0 +(3-ey)*GRIDWID,'z':-44}];
            var zz = BABYLON.MeshBuilder.CreateLines("highlightLines", {points: path, useVertexAlpha: false}, scene);
                zz.isPickable = false;
        }
        
        // Draw slots on the screen
        drawSlots = () => {
            for(var i=0; i<5; i++){
                var plane = BABYLON.MeshBuilder.CreatePlane("slot"+i, {sideOrientation: 3}, scene);
                    plane.scaling    = vec3(3, 3, 1)
                    plane.position   = vec3(24, 6-i*3.25, -30);
                    plane.visibility = 0.5;
                    plane.material   = eqSlot;
                    plane.rotation.y = Math.PI*0.8;
                drawText("slotT"+i, "", C[0], 7, vec3(20.5, 6.5-i*3.25, -32.5), Math.PI*0.8, 30);
                drawText("slotS"+i, "", C[0], 7, vec3(20.5, 5.6-i*3.25, -32.5), Math.PI*0.8, 36);
            }
        }
        
        // Draw options
        drawOptions = () => {
            drawText("optionsLabel", "OPTIONS", C[0], 10, vec3(15, 4.25, 15), optAngle, 50);
            drawText("voiceLabel1", "speechSynthesis API", C[1], 10, vec3(15, 3, 15),optAngle, 38);
            drawText("voiceLabel2", S[18], C[2], 10, vec3(15, 2.25, 15), optAngle, 32);
            drawText("qualityLabel1", "Quality", C[1], 10, vec3(15, 1, 15), optAngle, 38);
            drawText("qualityLabel2", S[17], C[2], 10, vec3(15, 0.25, 15), optAngle, 32);
            drawText("qualityLabel3", S[10]+"On", C[3], 10, vec3(15, -0.5, 15), optAngle, 24);
            drawText("qualityLabel4", S[11]+"On", C[3], 10, vec3(15, -0.9, 15), optAngle, 24);
            drawText("qualityLabel5", S[12]+"On", C[3], 10, vec3(15, -1.3, 15), optAngle, 24);
            drawText("qualityLabel6", S[13]+"On", C[3], 10, vec3(15, -1.7, 15), optAngle, 24);
            drawText("qualityLabel7", S[14]+"On", C[3], 10, vec3(15, -2.1, 15), optAngle, 24);
            drawText("deleteLabel", "DELETE ACHIEVEMENTS DATA", "#770000", 10, vec3(15, -5, 15), optAngle, 24);
        }
        
        // Draw achievements
        drawAchievments = () => {
            drawText("achivLabel", "ACHIEVEMENTS", C[0], 10, vec3(-15, 4.25, 15), optAngle2, 50);
            if(!localStorage.getItem('BACKUPachiv')){
                localStorage.setItem('BACKUPachiv', 0);
            } else {
                achiv = Number(localStorage.getItem('BACKUPachiv'));
            }
            drawText("achiv1Title", "Backup succesful?", (achiv&1)?C[2]:C[4], 10, vec3(-15, 3, 15), optAngle2, 30);
            drawText("achiv1Title", "Complete game with some memory lost", (achiv&1)?C[1]:C[4], 10, vec3(-15, 2.25, 15), optAngle2, 24);
            drawText("achiv2Title", "Back Entrence", (achiv&2)?C[2]:C[4], 10, vec3(-15, 1, 15), optAngle2, 30);
            drawText("achiv2Title", "Complete game without memory lost", (achiv&2)?C[1]:C[4], 10, vec3(-15, 0.25, 15), optAngle2, 24);
            drawText("achiv3Title", "No way to go back", (achiv&4)?C[2]:C[4], 10, vec3(-15, -1, 15), optAngle2, 30);
            drawText("achiv3Title", "Lost game because of memory lost", (achiv&4)?C[1]:C[4], 10, vec3(-15, -1.75, 15), optAngle2, 24);
        }
        
        // Draw HUD - text and meshes
        drawHUD = () => {
            // Draw toolbar [inventory] and memory size [health]
            drawText("storageLabel", S[1], C[1], 10, vec3(-20, -6, -30), Math.PI*1.2, 40);
            drawText("toolbarLabel", S[2], C[1], 10, vec3(20, 8, -30), Math.PI*0.8, 40);
            drawText("storage", "0/"+maxS+" B", C[0], 10, vec3(-20, -5, -30), Math.PI*1.2);
            
            // Draw slots of the toolbar
            drawSlots();
            
            // Create hero
            createHero();
        }
        
        /*
            ######################################################
            ### Camera control focus functions
        */
       
        // On click, focus camera on point
        focusCamera = a_where => {
            switch(a_where){
                case 0:
                    // Game board
                    VRhelper.currentVRCamera.setTarget(vec3(0,0,0));
                    return
                case 1:
                    // Options
                    VRhelper.currentVRCamera.setTarget(vec3(20.25,0,20));
                    return
                case 2:
                    // Achievments
                    VRhelper.currentVRCamera.setTarget(vec3(-20.25,0,20));
                    return
            }
        }
        
        /*
            ######################################################
            ### Game states funtions
        */
       
        // Create Logo
        createLogo = (a_only = false) => {
            // Draw Logo
            for(var i=0; i<5; i++){
                var logoRow = logo[i];
                var z = -12
                do{
                    if(logoRow&1){
                        var x = BABYLON.MeshBuilder.CreateBox("logo", {}, scene);
                            x.position = vec3(z*1.2, i*1.2, -40);
                            x.scaling  = vec3(1.2, 1.2, 0.25);
                            x.material = logoMaterials[ranRng(5)];
                        hl.addMesh(x, tex(1, 1, 1));
                    }
                    z++;
                }while(logoRow>>=1)
            }
            
            
            if(!a_only){
                // Append game start button and creators
                drawText("logoClick", S[0], C[5], 24, vec3(0, -2, -40), Math.PI);
                drawText("creators", S[4].split("").join(" "), C[4], 24, vec3(0, -10, -40), Math.PI, 32);
                drawText("l_options1", S[6], C[4], 24, vec3(20, -12, -40), Math.PI*0.8, 40);
                drawText("l_achiv1", S[7], C[4], 24, vec3(-20, -12, -40), Math.PI*1.2, 40);
                drawText("l_game1", S[8], C[4], 24, vec3(40, -9, 25), Math.PI*0.35, 40);
                drawText("l_achiv2", S[9], C[4], 24, vec3(25, -9, 40), Math.PI*0.15, 40);
                drawText("l_game2", S[23], C[4], 24, vec3(-40, -9, 25), Math.PI*1.65, 40);
                drawText("l_options2", S[24], C[4], 24, vec3(-25, -9, 40), Math.PI*1.85, 40);
                
                // Set game state
                gameState = 1;
            }
        }
        
        // When button below logo is clicked
        logoClicked = a_mesh => {
            if(!gameStarted){
                gameStarted = true;
                playClick();
                
                // Dispose clicked mesh and creators
                disap(a_mesh);
                disap(scene.getMeshByName("creators"));
                
                // Start game after timeout
                setTimeout(()=>{startGame();}, 300);
            }
        }
        
        // Start game after clicking start button
        startGame = () => {
            // Move back fog, logo and all data blocks
            goBackFog(90);
            scene.meshes.forEach(function(m){
                if(m.name == "logo"){
                    m.position.y += 50;
                    m.position.z -= 100;
                    hl.removeMesh(m);
                } else if(/data[0-9]+/.test(m.name)){
                    goBack(m, -100);
                }
            });
            
            // Draw HUD
            drawHUD();
            
            // Create back of the board
            var x = BABYLON.MeshBuilder.CreateBox("gridBack", {}, scene);
                x.position = vec3(0, 0, -50);
                x.scaling  = vec3(GRIDWID*GRIDSIZE+4, GRIDWID*GRIDSIZE+4, 0.25);
                x.material = gridBackMat;
                x.visibility = 0.9;
                
            // Create grid slots
            for(var i=0; i<GRIDSIZE; i++){
                for(var j=0; j<GRIDSIZE; j++){
                    let x = BABYLON.MeshBuilder.CreateBox("gridZ"+(i*8+j), {}, scene);
                        x.position = vec3(GRIDWID*(j-GRIDSIZE/2)+GRIDWID/2, GRIDWID*(i-GRIDSIZE/2)+GRIDWID/2, -45);
                        x.scaling  = vec3(GRIDWID-0.25, GRIDWID-0.25, 0.25);
                        x.material = nonGrid;
                        x.visibility = 0.98;
                    gridPos.push([GRIDWID*(j-GRIDSIZE/2)+GRIDWID/2, GRIDWID*(i-GRIDSIZE/2)+GRIDWID/2, -44]);
                }
            }
            
            // Change game state
            gameState = 2;
            
            // Start first dialog
            setTimeout(()=>{speakHero(0)}, 1000);
        }
        
        /*
            ######################################################
            ### Engine functions
        */
        
        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(() => {
            // Get animation ratio
            var animR = scene.getAnimationRatio();
            
            // Display FPS
            var fpsLabel = document.getElementById("fps");
            fpsLabel.innerHTML = engine.getFps().toFixed() + " fps";
            
            // Update meshes
            if(optQuality > 1){
                scene.meshes.forEach(function(m){
                    if(m.name == "logo" && Math.random() <= 0.005){
                        m.material = logoMaterials[ranRng(5)];
                    }
                });
            }
            
            // Board grid selected update
            var pi = scene.pick(can.width/2, can.height/2);
            if(pi.pickedMesh){
                var nme = pi.pickedMesh.name;
                if(nme.split("Z")[0] == "grid"){
                    scene.meshes.forEach(m=>{
                        if(/gridZ[0-9]+/.test(m.name)){
                            m.material = nonGrid;
                    }})
                    var u = Number(nme.split("Z")[1]);
                    if(cubeGrid[u]["destructable"] == true){
                        pi.pickedMesh.material = selPGrid;
                    } else {
                        pi.pickedMesh.material = selGrid;
                    }
                }
            }
            
            // Deal damage to memory
            if(dmgBuff){
                shakeCamera = (dmgBuff>3)?3:dmgBuff;
                actS += dmgBuff;
                changeText("storage", actS+"/"+maxS+" B", 10, C[5]);
            } else {
                shakeCamera = 0;
            }
            
            if(optQuality > 0 && !stopCameraShake){
                // Shake camera
                VRhelper.currentVRCamera.position = vec3(randS()*0.03*shakeCamera, randS()*0.03*shakeCamera, 1+randS()*0.03*shakeCamera);
                
                // Hero top and down movement
                if(isHero){
                    hero.position.y += Math.sin(heroMov)*0.01;
                    heroEyes.position.y += Math.sin(heroMov)*0.0075;
                    heroMov += animR*0.025*heroIsSpeaking
                }
            }
            
            // Check if we can place smth
            if(wantToPlace){
                if(mouseDown){
                    if(delet > 0){
                        delet -= animR;
                    } else {
                        deleteSmth(gridC);
                        wantToPlace = false;
                        delet = DELTIME;
                    }
                } else {
                    placeSmth(gridC);
                    wantToPlace = false;
                    delet = DELTIME;
                }
            }
            
            // Rotate crystal
            for(var i=0; i<cubeGrid.length; i++){
                if(cubeGrid[i]["type"] == "crystal"){
                    let calc = Math.PI*animR/50;
                    scene.getMeshByName("crystal"+i).rotation.z += (cubeGrid[i]["how"])?-calc:calc;
                }
            }
            
            if(memoLost == 0 && actS >= 6656){
                memoLost = 1;
                saySmth("Half memory lost! Watch out!", 1, "X", "X");
            } else if (memoLost == 1 && actS >= 9984){
                memoLost = 2;
                saySmth("We are losing too much memory!", 1, "X", "X");
            } else if (memoLost == 2 && actS >= 12288){
                memoLost = 3;
                saySmth("Soon system will crash!", 1, "X", "X");
            }
            
            // Gameover 3
            if(!isGameover && actS > maxS && gameWon == 0){
                isGameover = true;
                speakHero(74);
            }
            
            // Used for animating sky
            if(gameEnd){
                if(!isGameover){
                    //skyWhite();
                    isGameover = true;
                }
                skySeq += Math.PI/(500/animR);
                scene.clearColor = tex(0.5*Math.abs(Math.sin(skySeq)), 0, 0);
            }
            
            // Render scene
            scene.render();
        });
        
        /*
            ######################################################
            ### Window Events
        */
        
        // Watch for browser/canvas resize events
        window.addEventListener("resize", () => {
            can.width = window.innerWidth;
            can.height = window.innerHeight;
            engine.resize();
        });

        // On window click
        window.addEventListener("click", () => {
            var pi = scene.pick(can.width/2, can.height/2);
            if(pi.pickedMesh){
                var nme = pi.pickedMesh.name;
                if(!isGameover){
                    if(nme == "logoClick"){
                        logoClicked(pi.pickedMesh);
                    } else if(/slot[ST]?0/.test(nme)){
                        chooseSlot(0);
                        playClick();
                    } else if(/slot[ST]?1/.test(nme)){
                        chooseSlot(1);
                        playClick();
                    } else if(/slot[ST]?2/.test(nme)){
                        chooseSlot(2);
                        playClick();
                    } else if(/slot[ST]?3/.test(nme)){
                        chooseSlot(3);
                        playClick();
                    } else if(/slot[ST]?4/.test(nme)){
                        chooseSlot(4);
                        playClick();
                    } else if(/l_game[0-9]+/.test(nme)){
                        focusCamera(0);
                        playClick();
                    } else if(/l_options[0-9]+/.test(nme)){
                        focusCamera(1);
                        playClick();
                    } else if(/l_achiv[0-9]+/.test(nme)){
                        focusCamera(2);
                        playClick();
                    }
                }
                if(nme == "deleteLabel"){
                    localStorage.removeItem('BACKUPachiv');
                    playClick();
                } else if(nme == "gameoverLabel3"){
                    playClick();
                    location.reload(); 
                } else if(/qualityLabel[0-9]+/.test(nme)){
                    switchQuality();
                    playClick();
                } else if(/voiceLabel[0-9]+/.test(nme)){
                    switchVoice();
                    playClick();
                }
            }
            
            // Ask the browser to lock the pointer
            can.requestPointerLock = can.requestPointerLock || can.mozRequestPointerLock || can.webkitRequestPointerLock;
            can.requestPointerLock();
        });
        
        /*
            ######################################################
            ### Canvas Events
        */
        
        // When mouse is pressed
        can.addEventListener("pointerdown", () => {
            // Set var that mouse is pressed
            mouseDown = 1;
            
            // Handle mouse pressing on grid
            var pi = scene.pick(can.width/2, can.height/2);
            if(pi.pickedMesh){
                var nme = pi.pickedMesh.name;
                if(nme.split("Z")[0] == "grid"){
                    var u = Number(nme.split("Z")[1]);
                    if(cubeGrid[u]["type"] == "none" || cubeGrid[u]["destructable"]){
                        wantToPlace = true;
                        gridC = u;
                    }
                }
            }
        });
        
        // When mouse is realesed
        can.addEventListener("pointerup", () => {
            // Set var that mouse is released
            mouseDown = 0;
        });
        
        /*
            ######################################################
            ### Initialize whole game
        */
        
        // Main function
        main = () => {
            // Create scene first
            createScene();
            
            // Then create options and achievements
            drawOptions();
            drawAchievments();
            
            // Finally create logo and important buttons
            createLogo();
        };
        main();
        
        /*
            ### Special thanks to:
            @Jorengarenar (https://github.com/Jorengarenar)
            - for regex example
        */
    </script>
</html>