<!doctype html>
<html>
    <head>
        <script src="https://js13kgames.com/webxr-src/babylon.js"></script>
        <style>
            body {margin:0;overflow:hidden;}
            #fps { position: absolute; left: 20px; top: 20px; color: #999; font-family: "Courier New", Courier, monospace }
        </style>
    </head>
    <body>
        <canvas id="jj" touch-action="none"></canvas>
        <div id="fps"></div>
    </body>
    <script>
        /*
            0  - air
            1  - entr top
            2  - entr right
            3  - entr bottom
            4  - entr left
            5  - exit top
            6  - exit right
            7  - exit bottom
            8  - exit left
            9  - wall
            10 - reflector
        */
        /*
            ######################################################
            ### Preparation
        */
       
        // Set canvas size
        can = document.getElementById("jj");
        can.width = window.innerWidth;
        can.height = window.innerHeight;

        // Babylon engine on
        engine = new BABYLON.Engine(can, true);

        /*
            ######################################################
            ### Variables
        */
       
        // Logo compressed
        logo = [15395444,11438676,13274198,11176533,15657558];
        
        // Camera position
        camOff = new BABYLON.Vector3(0, 0, 1);
        
        // Game state
        gameState = 0;
        
        // Highlight layer
        var hl;
        
        // Materials
        logoMaterials = [];
        dataMaterials = [];
        var eqSlot, selGrid, nonGrid, curMat, wallMat, entrMat, reflMat, selSlot;
        
        // Game vars
        shakeCamera = 0;   // Camera shake level (0-3)
        
        actS = 0;      // Current memory size
        maxS = 13312;  // Total memory size
        dmgBuff = 0;   // Total damaged memory
        level = 0;     // Level we are playing right now
        exits = [0,0]  // Exited sucessfully/total exits
        
        slots = [[0,0],[0,0],[0,0],[0,0],[0,0]]; // Slot information
        slotC = -1;                              // Choosen toolbar slot
        
        gridPos = [];  // Position of all grid slots
        lasers = [];   // All created lasers
        
        delet = 40;           // Time to delete object
        mouseDown = 0;        // Is mouse down on canvas
        gridC = -1;           // Choosen grid slot
        wantToPlace = false;  // Do we want to place smth on the grid
        
        var vojc;      // English voice
        
        // Consts
        FONT     = "Consolas";
        GRIDSIZE = 8;
        GRIDWID  = 30/GRIDSIZE;
        /*
            Text:
            0 - logoLabel
            1 - memoryLabel
            2 - toolbarLabel
            3 - reflector
        */
        S = [
            "Click here to start playing", 
            "Memory size", 
            "Toolbar",
            "Reflector"
        ];
        
        /*
            Colors:
            0 - text
            1 - labels
        */
        C = ["#cacae7","#8e8ecc"];
        
        LEVELS = [
        [[512,4194304],[5,2],[10,1]],
        [[201326592,28],[9,7,1,9,9],[10,4]]
        ]
        
        // Game grid
        cubeGrid = Array(GRIDSIZE**2).fill({'type':'none','destructable':false})
        
        /*
            ######################################################
            ### Misc functions
        */
       
        ranRng = num => {
            return Math.floor(Math.random()*num);
        }
        
        tex = (r, g, b) => {
            return new BABYLON.Color3(r, g, b);
        }
        
        mate = (a_id, a_color, a_disLight=false) => {
            let a = new BABYLON.StandardMaterial(a_id, scene);
                a.emissiveColor = a_color;
                a.disableLighting = a_disLight;
            return a;
        }
        
        vec3 = (x, y, z) => {
            return new BABYLON.Vector3(x, y, z);
        }
        
        randS = () => {
            let r = Math.random();
            return (Math.random()<=0.5)?r:-r;
        }
        
        copyObj = (a_obj) => {
            return JSON.parse(JSON.stringify(a_obj));
        }
        
        /*
            ######################################################
            ### Material creation
        */
       
        materialCreation = () => {
            // Create colorful materials
            for(var i=0; i<5; i++){
                logoMaterials.push(mate("logoMat", tex(0.5+i*0.05, 0.9+i*0.025, 1), true));
            }
            
            // Create data materials
            for(var i=0; i<5; i++){
                dataMaterials.push(mate("dataMat", tex(0.3+i*0.05, 0.7+i*0.05, 1), true));
            }
            
            // cursor material
            curMat  = mate("curMat", tex(1, 1, 1), true);
            
            // equiped slot material
            eqSlot  = mate("eqSlot", tex(0.07, 0.07, 0.12), true);
            
            // selected slot material
            selSlot = mate("selSlot", tex(0.1, 0.1, 0.15), true);
            
            // selected grid
            selGrid = mate("selGrid", tex(0.035, 0.12, 0.22), true);
            
            // non-selected grid
            nonGrid = mate("nonGrid", tex(0.02, 0.02, 0.05), true);
            nonGrid.alpha = 0.7;
            
            // wall material
            wallMat = mate("wallMat", tex(0.6, 0.6, 0.6), true);
            
            // reflector material
            reflMat = mate("reflMat", tex(0.8, 0.8, 0.8));
            
            // entry material
            entrMat = mate("entrMat", tex(0, 0.5, 1));
            
            // exit material
            exitMat = mate("exitMat", tex(0.5, 0.1, 0.1));
        }
        
        /*
            ######################################################
            ### Scene creation
        */
       
        createScene = () => {
            // Create new scene and add needed options
            scene = new BABYLON.Scene(engine);
            scene.constantlyUpdateMeshUnderPointer = true;
            
            // Set fog
            scene.fogMode  = 3; //BABYLON.Scene.FOGMODE_LINEAR
            scene.fogStart = 50;
            scene.fogEnd   = 75;

            // set background
            scene.clearColor = tex(0.05, 0.05, 0.1);
            
            // Set global light
            g_light = new BABYLON.PointLight("light", camOff, scene);
            g_light.intensity = 0.17;
            
            // Create highlight layer
            hl = new BABYLON.HighlightLayer("hl1", scene);
            
            // Create camera
            camera = new BABYLON.FreeCamera("camera", camOff, scene);
            camera.inertia = 0
            camera.angularSensibility = 300
            
            // Target camera at 0,0,0
            camera.setTarget(BABYLON.Vector3.Zero());
            camera.attachControl(can, true);
            camera.inputs.remove(camera.inputs.attached.keyboard);
            
            materialCreation()
            
            // Create background data blocks
            for(var i=0; i<200; i++){
                pl = BABYLON.MeshBuilder.CreatePlane("data", {sideOrientation: 1}, scene)
                pl.position  = vec3(Math.random()*100-50, Math.random()*30-13, -60-Math.random()*5);
                pl.material  = dataMaterials[ranRng(5)];
                pl.scaling.x = 3
            }
            
            // Create cursor pointer
            cur = BABYLON.MeshBuilder.CreateBox("cursor", {}, scene);
            cur.scaling    = vec3(0.01, 0.01, 0.01)
            cur.parent     = camera
            cur.position   = vec3(0, 0, 2);
            cur.material   = curMat;
            cur.isPickable = false
            
            // Create glow layer
            var gl = new BABYLON.GlowLayer("", scene);
            gl.customEmissiveColorSelector = (mesh, subMesh, material, result) => {
                if(mesh.name == "laserLines"){
                    result.set(0,0.5,1,1);
                } else {
                    result.set(0,0,0,0);
                }
            }
        }
        createScene();
        
        /*
            ######################################################
            ### Game speech
        */
        
        // Choose english language
        setUpSpeaking = (a_voices) => {
            for(var i=0; i<a_voices.length; i++){
                if(a_voices[i].lang == "en-US"){
                    vojc = a_voices[i];
                }
            }
        }
    
        // Say something if there is english voice
        saySmth = (a_text, a_rate=1) => {
            if(vojc){
                let pre = new SpeechSynthesisUtterance(a_text);
                    pre.pitch = 2;
                    pre.rate = a_rate;
                    pre.voice = vojc
                window.speechSynthesis.speak(pre)
            }
        }
        
        // Create timer which will check if there are any voices
        var timer = setInterval(function() {
            var voices = speechSynthesis.getVoices();
            if (voices.length !== 0) {
                setUpSpeaking(voices)
                clearInterval(timer);
            }
        }, 200);
            
        /*
            ######################################################
            ### Text drawing functions
        */
       
        // Create/Update text
        drawText = (a_id, a_text, a_color, a_width, a_pos, a_rot, a_fontSize=60) => {
            var plane = BABYLON.MeshBuilder.CreatePlane(a_id, {width: a_width, height: 1, sideOrientation: 2}, scene);
                plane.position   = a_pos;
                plane.rotation.y = a_rot;
            var wid = a_width*60;
            var cFont = a_fontSize + "px " + FONT;
            var dynamo = new BABYLON.DynamicTexture("dynText", {width:wid, height: 60}, scene);
                dynamo.hasAlpha = true;
                dynamo.getContext().font = cFont;
                dynamo.drawText(a_text, null, null, cFont, a_color ,"transparent", true, true);
            let mat = mate("mat", vec3(1, 1, 1), true);
                mat.diffuseTexture  = dynamo;
            plane.material = mat;
        }

        changeText = (a_mesh, a_text, a_wid, a_color, a_fontSize=60) => {
            var t_mesh = scene.getMeshByName(a_mesh);
            if(t_mesh != null){
                let cFont = a_fontSize + "px " + FONT;
                let dynamo = t_mesh.material.diffuseTexture
                let ctx = dynamo.getContext();
                    ctx.clearRect(0, 0, a_wid*60, 60)
                    ctx.font = cFont;
                dynamo.drawText(a_text, null, null, cFont, a_color, "transparent", true, true);
            }
        }
        
        /*
            ######################################################
            ### Handle slots
        */

        chooseSlot = (x) => {
            slotC = x;
            for(var i=0; i<5; i++){
                var m = scene.getMeshByName("slot"+i);
                if(i==x){
                    m.material = selSlot;
                    m.visibility = 0.98;
                } else {
                    m.visibility = (slots[i][0] != 0)?0.98:0.5;
                    m.material   = eqSlot;
                }
            }
        }
        
        whatName = (x) => {
            switch(x){
                case 10:
                    return S[3];
                default:
                    return "";
            }
        }
        
        /*
            ######################################################
            ### Easing animation
        */
        
        goBackFog = (a_to) => {
            if(scene.fogStart < a_to){
                scene.fogStart += 0.25
                scene.fogEnd += 0.25
                setTimeout(()=>{goBackFog(a_to)},10)
            }
        }
        
        goBack = (a_mesh, a_pos) => {
            if(a_mesh.position.z >= a_pos){
                a_mesh.position.x = 1.002*a_mesh.position.x
                a_mesh.position.y = 1.002*a_mesh.position.y
                a_mesh.position.z -= 0.25
                setTimeout(()=>{goBack(a_mesh, a_pos)},10)
            }
        }
        
        disap = (a_mesh, a_scale={x:1,y:1,z:1}) => {
            if(a_mesh.scaling.x > 0){
                a_mesh.scaling.x -= 0.05*a_scale.x
                a_mesh.scaling.y -= 0.05*a_scale.y
                a_mesh.scaling.z -= 0.05*a_scale.z
                setTimeout(()=>{disap(a_mesh,a_scale)},10)
            } else {
                a_mesh.dispose();
            }
        }
        
        /*
            ######################################################
            ### Placing/Deleting/Rotating objects
        */
       
        rotateSmth = (a_slot) => {
            switch(cubeGrid[a_slot]["type"]){
                case "reflector":
                    if(cubeGrid[a_slot]["how"]==0){
                        scene.getMeshByName("reflector"+a_slot).rotation.z = Math.PI*0.75;
                        cubeGrid[a_slot]["how"]=1;
                    } else {
                        scene.getMeshByName("reflector"+a_slot).rotation.z = Math.PI*0.25;
                        cubeGrid[a_slot]["how"]=0;
                    }
                    break;
            }
            startLaser();
        }
        
        placeSmth = (a_slot) => {
            if(slots[slotC][0] != 0 && slots[slotC][1] > 0 && cubeGrid[a_slot]["type"] == "none"){
                switch(slots[slotC][0]){
                    case 10:
                        x = BABYLON.MeshBuilder.CreateBox("reflector"+a_slot, {}, scene);
                        x.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1],gridPos[a_slot][2]-1);
                        x.scaling  = vec3(GRIDWID-0.5, 0.1, 0.5);
                        x.rotation = vec3(0,0,Math.PI*0.25)
                        x.material = reflMat;
                        x.isPickable = false
                        cubeGrid[a_slot] = {"type": "reflector", "how": 0, "destructable": true}
                        break;
                }
                slots[slotC][1]--;
                changeText("slotS"+slotC,slots[slotC][1],7,C[1],32);
                startLaser();
            } else if(cubeGrid[a_slot]["type"] != "none" && cubeGrid[a_slot]["destructable"]){
                rotateSmth(a_slot);
            }
        }
        
        addItem = (a_type) => {
            for(var i=0; i<5; i++){
                if(slots[i][0] == a_type){
                    slots[i][1]++;
                    changeText("slotS"+i, slots[i][1], 7, C[1], 32);
                    break
                }
            }
        }
        
        deleteSmth = (a_slot) => {
            if(cubeGrid[a_slot]["destructable"]){
                switch(cubeGrid[a_slot]["type"]){
                    case "reflector":
                        var a = scene.getMeshByName("reflector"+a_slot);
                        if(a){
                            disap(a,copyObj(a.scaling))//.dispose()
                            cubeGrid[a_slot] = {"type": "none"}
                            addItem(10)
                        }
                        break;
                }
                startLaser();
            }
        }
       
        /*
            ######################################################
            ### Process level
        */
        
        startLaser = () => {
            dmgBuff = 0;
            exits[0] = 0;
            let a = scene.getMeshByName("laserLines")
            if(a){
                a.dispose()
            }
            for(var i=0; i<lasers.length; i++){
                var path = []
                var slote = lasers[i]["slot"];
                var pos = gridPos[lasers[i]["slot"]].slice();
                var dir = lasers[i]["dir"]
                path.push(pos.slice());
                isFine = 100
                while(isFine){
                    switch(dir){
                        case 0:
                            if(slote+GRIDSIZE > GRIDSIZE**2){
                                isFine = 0;
                                dmgBuff++;
                                pos[1] += GRIDWID/2;
                            } else {
                                slote += GRIDSIZE;
                                var z = cubeGrid[slote]["type"];
                                if(z == "reflector"){
                                    dir = 3-2*cubeGrid[slote]["how"];
                                } else if(z == "wall" || z == "entry"){
                                    isFine = 0;
                                } else if(z == "exit"){
                                    if(cubeGrid[slote]["where"] == 2){
                                        exits[0]++;
                                    }
                                    isFine = 0;
                                } 
                                pos[1] += GRIDWID;
                            }
                            break;
                        case 1:
                            if((slote-1)%GRIDSIZE > slote%GRIDSIZE){
                                isFine = 0;
                                dmgBuff++;
                                pos[0] -= GRIDWID/2;
                            } else {
                                slote -= 1;
                                var z = cubeGrid[slote]["type"];
                                if(z == "reflector"){
                                    dir = 2-2*cubeGrid[slote]["how"];
                                } else if(z == "wall" || z == "entry"){
                                    isFine = 0;
                                } else if(z == "exit"){
                                    if(cubeGrid[slote]["where"] == 3){
                                        exits[0]++;
                                    }
                                    isFine = 0;
                                } 
                                pos[0] -= GRIDWID;
                            }
                            break;
                        case 2:
                            if(slote-GRIDSIZE < 0){
                                isFine = 0;
                                dmgBuff++;
                                pos[1] -= GRIDWID/2;
                            } else {
                                slote -= GRIDSIZE;
                                var z = cubeGrid[slote]["type"];
                                if(z == "reflector"){
                                    dir = 1+2*cubeGrid[slote]["how"];
                                } else if(z == "wall" || z == "entry"){
                                    isFine = 0;
                                } else if(z == "exit"){
                                    if(cubeGrid[slote]["where"] == 0){
                                        exits[0]++;
                                    }
                                    isFine = 0;
                                } 
                                pos[1] -= GRIDWID;
                            }
                            break;
                        case 3:
                            if((slote+1)%GRIDSIZE < slote%GRIDSIZE){
                                isFine = 0;
                                dmgBuff++;
                                pos[0] += GRIDWID/2;
                            } else {
                                slote += 1;
                                var z = cubeGrid[slote]["type"];
                                if(z == "reflector"){
                                    dir = 0+2*cubeGrid[slote]["how"];
                                } else if(z == "wall" || z == "entry"){
                                    isFine = 0;
                                } else if(z == "exit"){
                                    if(cubeGrid[slote]["where"] == 1){
                                        exits[0]++;
                                    }
                                    isFine = 0;
                                } 
                                pos[0] += GRIDWID;
                            }
                            break;
                    }
                    if(isFine){ isFine--; }
                    path.push(pos.slice());
                }
                for(var j=0;j<path.length;j++){
                    path[j] = {'x':path[j][0],'y':path[j][1],'z':path[j][2]-0.7};
                }
                var zz = BABYLON.MeshBuilder.CreateLines("laserLines", {points: path, useVertexAlpha: false}, scene);
                zz.isPickable = false
            }
            if(exits[0]==exits[1] && exits[1] != 0){
                if(++level!=LEVELS.length){
                    processLevel();
                } else {
                    resetLevel()
                    console.log("!")
                }
            }
        }
        
        createEntr = (a_slot, a_fau) => {
            var y = BABYLON.MeshBuilder.CreateBox("gridEntryFaucet"+a_slot, {}, scene);
                y.scaling  = vec3(0.4, 0.4, 1.5);
                y.material = entrMat;
                y.isPickable = false
            switch(a_fau){
                case 0:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]+1,gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"entry","where":0,"destructable":false}
                    lasers.push({"slot":a_slot,"dir":0})
                    break;
                case 1:
                    y.position = vec3(gridPos[a_slot][0]-1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"entry","where":1,"destructable":false}
                    lasers.push({"slot":a_slot,"dir":1})
                    break;
                case 2:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]-1,gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"entry","where":2,"destructable":false}
                    lasers.push({"slot":a_slot,"dir":2})
                    break;
                case 3:
                    y.position = vec3(gridPos[a_slot][0]+1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"entry","where":3,"destructable":false}
                    lasers.push({"slot":a_slot,"dir":3})
                    break;
            }
            var x = BABYLON.MeshBuilder.CreateBox("gridEntry"+a_slot, {}, scene);
                x.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1],gridPos[a_slot][2]);
                x.scaling  = vec3(GRIDWID-2, GRIDWID-2, 2);
                x.material = entrMat;
                x.isPickable = false
        }
        
        createExit = (a_slot, a_fau) => {
            var y = BABYLON.MeshBuilder.CreateBox("gridExitFaucet"+a_slot, {}, scene);
                y.scaling  = vec3(0.4, 0.4, 1.5);
                y.material = exitMat;
                y.isPickable = false
            switch(a_fau){
                case 0:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]+1,gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"exit","where":0,"destructable":false}
                    break;
                case 1:
                    y.position = vec3(gridPos[a_slot][0]-1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"exit","where":1,"destructable":false}
                    break;
                case 2:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]-1,gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"exit","where":2,"destructable":false}
                    break;
                case 3:
                    y.position = vec3(gridPos[a_slot][0]+1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"exit","where":3,"destructable":false}
                    break;
            }
            exits[1]++;
            var x = BABYLON.MeshBuilder.CreateBox("gridExit"+a_slot, {}, scene);
                x.position = vec3(gridPos[a_slot][0], gridPos[a_slot][1], gridPos[a_slot][2]);
                x.scaling  = vec3(GRIDWID-2, GRIDWID-2, 2);
                x.material = exitMat;
                x.isPickable = false
        }
        
        createWall = (a_slot) => {
            var x = BABYLON.MeshBuilder.CreateBox("gridWall"+a_slot, {}, scene);
                x.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1],gridPos[a_slot][2]);
                x.scaling  = vec3(GRIDWID-0.5, GRIDWID-0.5, 2);
                x.material = wallMat;
                x.isPickable = false;
            cubeGrid[a_slot] = {"type":"wall","destructable":false}
        }
        
        resetLevel = () => {
            // Reset variables
            exits = [0,0];
            lasers = [];
            slots = [[0,0],[0,0],[0,0],[0,0],[0,0]];
            for(var i=0; i<GRIDSIZE**2; i++){
                cubeGrid[i] = {'type':'none','destructable':false};
            }
            
            // Clear meshes
            var names = []
            scene.meshes.forEach(m=>{
                if(/gridExitFaucet[0-9]+/.test(m.name)){
                    names.push(m.name)
                } else if(/gridExit[0-9]+/.test(m.name)){
                    names.push(m.name)
                } else if(/gridEntryFaucet[0-9]+/.test(m.name)){
                    names.push(m.name)
                } else if(/gridEntry[0-9]+/.test(m.name)){
                    names.push(m.name)
                } else if(/gridWall[0-9]+/.test(m.name)){
                    names.push(m.name)
                } else if(/reflector[0-9]+/.test(m.name)){
                    names.push(m.name)
                } 
            });
            names.forEach(m=>{
                disap(scene.getMeshByName(m), copyObj(scene.getMeshByName(m).scaling)) //.dispose()
            })
            let z = scene.getMeshByName("laserLines");
            if(z){
                z.dispose()
            }
        }
        
        processLevel = () => {
            resetLevel();
            var data = LEVELS[level][0];
            var slotk = 0;
            var blk = 0;
            for(var i=0; i<data.length; i++){
                do{
                    if(data[i]&1){
                        switch(LEVELS[level][1][blk]){
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                createEntr(slotk, LEVELS[level][1][blk]-1);
                                break;
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                                createExit(slotk, LEVELS[level][1][blk]-5);
                                break;
                            case 9:
                                createWall(slotk);
                                break;
                            default:
                                x = BABYLON.MeshBuilder.CreateBox("gridPoz", {}, scene);
                                x.position = vec3(gridPos[slotk][0],gridPos[slotk][1],gridPos[slotk][2]);
                                x.scaling  = vec3(GRIDWID-0.25, GRIDWID-0.25, 0.25);
                                x.material = logoMaterials[ranRng(5)];
                                x.isPickable = false
                                break;
                        }
                        blk++;
                    }
                    data[i] >>= 1;
                    slotk++;
                }while(slotk%32 != 0);
            }
            for(var i=0; i<LEVELS[level][2].length; i+=2){
                slots[Math.floor(i/2)] = [LEVELS[level][2][i], LEVELS[level][2][i+1]]
                changeText("slotT"+Math.floor(i/2),whatName(LEVELS[level][2][i]),7,C[0],36)
                changeText("slotS"+Math.floor(i/2),LEVELS[level][2][i+1],7,C[1],32)
            }
            chooseSlot(0);
        }
        
        /*
            ######################################################
            ### Game states funtions
        */
        
        drawSlots = () => {
            for(var i=0; i<5; i++){
                var plane = BABYLON.MeshBuilder.CreatePlane("slot"+i, {sideOrientation: 3}, scene);
                    plane.scaling    = vec3(3, 3, 1)
                    plane.position   = vec3(24, 6-i*3.25, -30);
                    plane.visibility = 0.5;
                    drawText("slotT"+i, "", C[0], 7, vec3(20.5, 6.5-i*3.25, -32.5), Math.PI*0.8, 30);
                    drawText("slotS"+i, "", C[0], 7, vec3(20.5, 5.6-i*3.25, -32.5), Math.PI*0.8, 36);
                    plane.material   = eqSlot
                    plane.rotation.y = Math.PI*0.8;
            }
        }
        
        // Create Logo
        createLogo = () => {
            for(var i=0; i<5; i++){
                var z = -12
                do{
                    if(logo[i]&1){
                        x = BABYLON.MeshBuilder.CreateBox("logo", {}, scene);
                        x.position = vec3(z*1.2, i*1.2, -40);
                        x.scaling  = vec3(1.2, 1.2, 0.25);
                        x.material = logoMaterials[ranRng(5)];
                        hl.addMesh(x, tex(1, 1, 1));
                    }
                    z++;
                }while(logo[i]>>=1)
            }
            drawText("logoClick", S[0], "#ffffff", 24, vec3(0, -2, -40), Math.PI);
            drawText("storageLabel", S[1], C[1], 10, vec3(-20, -6, -30), Math.PI*1.2, 40);
            drawText("toolbarLabel", S[2], C[1], 10, vec3(20, 8, -30), Math.PI*0.8, 40);
            drawText("storage", "0/"+maxS+" B", C[0], 10, vec3(-20, -5, -30), Math.PI*1.2);
            drawSlots();
            gameState = 1;
        }
        createLogo();
        
        startGame = (a_label) => {
            goBackFog(90);
            scene.meshes.forEach(function(m){
                if(m.name == "logo"){
                    m.position.y += 50;
                    m.position.z -= 100;
                    hl.removeMesh(m);
                } else if(m.name == "data"){
                    goBack(m, -100)
                }
            });
            //a_label.dispose();
            var mati2 = mate("gridMat");
                mati2.emissiveColor   = tex(0.07, 0.07, 0.12); //tex(0.05, 0.16, 0.30)
                mati2.disableLighting = true;
            var x = BABYLON.MeshBuilder.CreateBox("gridBack", {}, scene);
                x.position = vec3(0, 0, -50);
                x.scaling  = vec3(GRIDWID*GRIDSIZE+4, GRIDWID*GRIDSIZE+4, 0.25);
                x.material = mati2;
                x.visibility = 0.9
            for(var i=0; i<GRIDSIZE; i++){
                for(var j=0; j<GRIDSIZE; j++){
                    let x = BABYLON.MeshBuilder.CreateBox("gridZ"+(i*8+j), {}, scene);
                        x.position = vec3(GRIDWID*(j-GRIDSIZE/2)+GRIDWID/2, GRIDWID*(i-GRIDSIZE/2)+GRIDWID/2, -45);
                        gridPos.push([GRIDWID*(j-GRIDSIZE/2)+GRIDWID/2, GRIDWID*(i-GRIDSIZE/2)+GRIDWID/2, -44])
                        x.scaling  = vec3(GRIDWID-0.25, GRIDWID-0.25, 0.25);
                        x.material = nonGrid;
                        x.visibility = 0.98
                }
            }
            processLevel();
        }
        
        /*
            ######################################################
            ### Engine functions
        */

        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(() => {
            // Display FPS
            var fpsLabel = document.getElementById("fps");
            fpsLabel.innerHTML = engine.getFps().toFixed() + " fps";
            
            // Update meshes
            var pickResult = scene.pick(scene.pointerX, scene.pointerY);
            scene.meshes.forEach(function(m){
                if(m.name == "logo" && Math.random() <= 0.005){
                    m.material = logoMaterials[ranRng(5)]
                } else if(m.name == "grid"){
                    m.material = nonGrid;
                } //else if(m.name == "data"){
                //    m.position.x += (Math.random()-0.5)*0.025
                //}
            });
            
            // Board grid selected update
            //var pi = scene.pick(scene.pointerX, scene.pointerY);
            var pi = scene.pick(can.width/2, can.height/2);
            if(pi.pickedMesh){
                if(pi.pickedMesh.name == "grid"){
                    pi.pickedMesh.material = selGrid;
                }
            }
            
            // Shake camera
            switch(shakeCamera){
                case 1:
                    camera.position = vec3(randS()*0.05, randS()*0.05, 1+randS()*0.05);
                    break;
                case 2:
                    camera.position = vec3(randS()*0.1, randS()*0.1, 1+randS()*0.1);
                    break;
                case 3:
                    camera.position = vec3(randS()*0.2, randS()*0.2, 1+randS()*0.2);
                    break;
            }
            
            // Check if we can place smth
            if(wantToPlace){
                if(mouseDown){
                    if(delet > 0){
                        delet -= scene.getAnimationRatio()
                    } else {
                        deleteSmth(gridC)
                        wantToPlace = false;
                        delet = 30;
                    }
                } else {
                    placeSmth(gridC)
                    wantToPlace = false;
                    delet = 30;
                }
            }
            
            // Deal damage to memory
            if(dmgBuff){
                shakeCamera = (dmgBuff>3)?3:dmgBuff;
                actS+=dmgBuff;
                changeText("storage",actS+"/"+maxS+" B",10,"#ffffff")
            } else {
                shakeCamera = 0;
            }
            
            // Render scene
            scene.render();
        });

        /*
            ######################################################
            ### Window Events
        */
        
        // Watch for browser/canvas resize events
        window.addEventListener("resize", function() {
            can.width = window.innerWidth;
            can.height = window.innerHeight;
            engine.resize();
        });

        // On window click
        window.addEventListener("click", function(){
            //var pi = scene.pick(scene.pointerX, scene.pointerY);
            var pi = scene.pick(can.width/2, can.height/2);
            if(pi.pickedMesh){
                var nme = pi.pickedMesh.name;
                if(nme == "logoClick"){
                    disap(pi.pickedMesh);
                    setTimeout(()=>{startGame(pi.pickedMesh);},200);
                } else if(/slot[ST]?0/.test(nme)){
                    chooseSlot(0);
                } else if(/slot[ST]?1/.test(nme)){
                    chooseSlot(1);
                } else if(/slot[ST]?2/.test(nme)){
                    chooseSlot(2);
                } else if(/slot[ST]?3/.test(nme)){
                    chooseSlot(3);
                } else if(/slot[ST]?4/.test(nme)){
                    chooseSlot(4);
                } 
            }
            
            // Ask the browser to lock the pointer
            can.requestPointerLock = can.requestPointerLock || can.mozRequestPointerLock || can.webkitRequestPointerLock;
            can.requestPointerLock();
        });
        
        /*
            ######################################################
            ### Canvas Events
        */
        
        can.addEventListener("pointerdown", ()=>{
            mouseDown = 1;
            var pi = scene.pick(can.width/2, can.height/2);
            if(pi.pickedMesh){
                var nme = pi.pickedMesh.name;
                if(nme.split("Z")[0] == "grid"){
                    var u = Number(nme.split("Z")[1]);
                    if(cubeGrid[u]["type"] == "none" || cubeGrid[u]["destructable"]){
                        wantToPlace = true;
                        gridC = u;
                    }
                }
            }
        });
        
        can.addEventListener("pointerup", ()=>{
            mouseDown=0;
        });
        
        /*
            FOR LATER USE
            
            scene.getAnimationRatio()
        */
       
        /*
            ### Special thanks to:
            @Jorengarenar (https://github.com/Jorengarenar)
            - for regex example
        */
    </script>
</html>