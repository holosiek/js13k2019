<!doctype html>
<html>
    <head>
        <script src="https://js13kgames.com/webxr-src/babylon.js"></script>
        <style>
            body {margin:0;overflow:hidden;}
            #fps { position: absolute; left: 20px; top: 20px; color: #999; font-family: "Courier New", Courier, monospace }
        </style>
    </head>
    <body>
        <canvas id="jj" touch-action="none"></canvas>
        <div id="fps"></div>
    </body>
    <script>
        /*
            0  - air
            1  - entr top
            2  - entr right
            3  - entr bottom
            4  - entr left
            5  - exit top
            6  - exit right
            7  - exit bottom
            8  - exit left
            9  - wall
            10 - reflector
        */
        /*
            ######################################################
            ### Preparation
        */
       
        // Set canvas size
        can = document.getElementById("jj");
        can.width = window.innerWidth;
        can.height = window.innerHeight;

        // Babylon engine on
        engine = new BABYLON.Engine(can, true);

        /*
            ######################################################
            ### Variables
        */
       
        // Logo compressed
        logo = [15395444,11438676,13274198,11176533,15657558];
        
        // Camera position
        camOff = new BABYLON.Vector3(0, 0, 1);
        
        // Game state
        gameState = 0;
        
        // Highlight layer
        var hl;
        
        // Materials
        logoMaterials = [];
        dataMaterials = [];
        var eqSlot, selGrid, nonGrid, curMat, wallMat, entrMat, reflMat, selSlot;
        
        // Game vars
        actS = 0;
        maxS = 13312;
        slotC = -1;
        level = 1;
        lasers = [];
        slots = [[0,0],[0,0],[0,0],[0,0],[0,0]];
        shakeCamera = 0;
        gridPos = []
        
        // Consts
        FONT     = "Consolas";
        GRIDSIZE = 8;
        GRIDWID  = 30/GRIDSIZE;
        /*
            Text:
            0 - logoLabel
            1 - memoryLabel
            2 - toolbarLabel
            3 - \ reflector
        */
        S = [
            "Click here to start playing", 
            "Memory size", 
            "Toolbar",
            "Reflector"
        ];
        
        /*
            Colors:
            0 - text
            1 - labels
        */
        C = ["#cacae7","#8e8ecc"];
        
        LEVELS = [
        [[512,4194304],[5,2],[10,1]],
        [[201326592,28],[9,7,1,9,9],[10,4]]
        ]
        
        // Game grid
        cubeGrid = Array(GRIDSIZE**2).fill({'type':'none'})
        
        /*
            ######################################################
            ### Misc functions
        */
       
        ranRng = num => {
            return Math.floor(Math.random()*num);
        }
        
        tex = (r, g, b) => {
            return new BABYLON.Color3(r, g, b);
        }
        
        mate = (a_id) => {
            return new BABYLON.StandardMaterial(a_id, scene);
        }
        
        vec3 = (x, y, z) => {
            return new BABYLON.Vector3(x, y, z);
        }
        
        randS = () => {
            let r = Math.random();
            return (Math.random()<=0.5)?r:-r;
        }
        
        /*
            ######################################################
            ### Material creation
        */
       
        materialCreation = ()=>{
            // Create colorful materials
            for(var i=0; i<5; i++){
                var mati = mate("logoMat");
                //mati.emissiveColor = new BABYLON.Color3(0.3+i*0.05,0.7+i*0.025,1);
                mati.emissiveColor   = tex(0.5+i*0.05, 0.9+i*0.025, 1);
                mati.disableLighting = true;
                logoMaterials.push(mati);
            }
            
            // Create data materials
            for(var i=0; i<5; i++){
                var mati = mate("dataMat");
                mati.emissiveColor   = tex(0.3+i*0.05, 0.7+i*0.05, 1);
                mati.disableLighting = true;
                dataMaterials.push(mati);
            }
            
            // cursor material
            curMat = mate("curMat");
            curMat.emissiveColor   = tex(1, 1, 1);
            curMat.disableLighting = true;
            
            // equiped slot material
            eqSlot = mate("eqSlot");
            eqSlot.emissiveColor   = tex(0.07, 0.07, 0.12);
            eqSlot.disableLighting = true;
            
            // selected slot material
            selSlot = mate("selSlot");
            selSlot.emissiveColor   = tex(0.1, 0.1, 0.15);
            selSlot.disableLighting = true;
            
            // selected grid
            selGrid = mate("selGrid");
            selGrid.emissiveColor   = tex(0.035, 0.12, 0.22);
            selGrid.disableLighting = true;
            
            // non-selected grid
            nonGrid = mate("nonGrid");
            nonGrid.emissiveColor   = tex(0.02, 0.02, 0.05);//tex(0.025, 0.08, 0.15);
            nonGrid.disableLighting = true;
            nonGrid.alpha = 0.7
            
            // wall material
            wallMat = mate("wallMat");
            wallMat.emissiveColor   = tex(0.6, 0.6, 0.6);
            wallMat.disableLighting = true;
            
            // reflector material
            reflMat = mate("reflMat");
            reflMat.emissiveColor   = tex(0.8, 0.8, 0.8);
            
            // entry material
            entrMat = mate("entrMat");
            entrMat.emissiveColor   = tex(0, 0.5, 1);
            
            // exit material
            exitMat = mate("exitMat");
            exitMat.emissiveColor   = tex(0.5, 0.1, 0.1);
        }
        
        /*
            ######################################################
            ### Scene creation
        */
       
        // Create new scene and add needed options
        scene = new BABYLON.Scene(engine);
        scene.constantlyUpdateMeshUnderPointer = true;
        
        // Set fog
        scene.fogMode  = 3; //BABYLON.Scene.FOGMODE_LINEAR
        scene.fogStart = 50;
        scene.fogEnd   = 75;

        // set background
        scene.clearColor = tex(0.05, 0.05, 0.1);
        
        // Set global light
        g_light = new BABYLON.PointLight("light", camOff, scene);
        g_light.intensity = 0.17;
        
        // Create highlight layer
        hl = new BABYLON.HighlightLayer("hl1", scene);
        
        // Create camera
        camera = new BABYLON.FreeCamera("camera", camOff, scene);
        camera.inertia = 0
        camera.angularSensibility = 300
        
        // Target camera at 0,0,0
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.attachControl(can, true);
        camera.inputs.remove(camera.inputs.attached.keyboard);
        
        materialCreation()
        
        // Create background data blocks
        for(var i=0; i<200; i++){
            pl = BABYLON.MeshBuilder.CreatePlane("data", {sideOrientation: 1}, scene)
            pl.position  = vec3(Math.random()*100-50, Math.random()*30-13, -60-Math.random()*5);
            pl.material  = dataMaterials[ranRng(5)];
            pl.scaling.x = 3
        }
        
        // Create cursor pointer
        cur = BABYLON.MeshBuilder.CreateBox("cursor", {}, scene);
        cur.scaling    = vec3(0.01, 0.01, 0.01)
        cur.parent     = camera
        cur.position   = vec3(0, 0, 2);
        cur.material   = curMat;
        cur.isPickable = false

        /*
            ######################################################
            ### Text drawing functions
        */
       
        // Create/Update text
        drawText = (a_id, a_text, a_color, a_width, a_pos, a_rot, a_fontSize=60) => {
            var plane = BABYLON.MeshBuilder.CreatePlane(a_id, {width: a_width, height: 1, sideOrientation: 2}, scene);
                plane.position   = a_pos;
                plane.rotation.y = a_rot;
            var wid = a_width*60;
            var cFont = a_fontSize + "px " + FONT;
            var dynamo = new BABYLON.DynamicTexture("dynText", {width:wid, height: 60}, scene);
                dynamo.hasAlpha = true;
                dynamo.getContext().font = cFont;
                dynamo.drawText(a_text, null, null, cFont, a_color ,"transparent", true, true);
            let mat = mate("mat");
                mat.diffuseTexture  = dynamo;
                mat.emissiveColor   = vec3(1, 1, 1)
                mat.disableLighting = true;
            plane.material = mat;
        }

        changeText = (a_mesh, a_text, a_wid, a_color, a_fontSize=60) => {
            var t_mesh = scene.getMeshByName(a_mesh);
            if(t_mesh != null){
                let cFont = a_fontSize + "px " + FONT;
                let dynamo = t_mesh.material.diffuseTexture
                let ctx = dynamo.getContext();
                    ctx.clearRect(0, 0, a_wid*60, 60)
                    ctx.font = cFont;
                dynamo.drawText(a_text, null, null, cFont, a_color, "transparent", true, true);
            }
        }
        
        /*
            ######################################################
            ### Handle slots
        */

        chooseSlot = (x) => {
            slotC = x
            for(var i=0; i<5; i++){
                var m = scene.getMeshByName("slot"+i)
                if(i==x){
                    m.material = selSlot;
                    m.visibility = 0.98;
                } else {
                    m.visibility = (slots[i][0] != 0)?0.98:0.5;
                    m.material   = eqSlot
                }
            }
        }
        
        whatName = (x) => {
            switch(x){
                case 10:
                    return S[3];
                default:
                    return "";
            }
        }
        
        /*
            ######################################################
            ### Easing animation
        */
        
        goBackFog = (a_to) => {
            if(scene.fogStart < a_to){
                scene.fogStart += 0.25
                scene.fogEnd += 0.25
                setTimeout(()=>{goBackFog(a_to)},10)
            }
        }
        
        goBack = (a_mesh, a_pos) => {
            if(a_mesh.position.z >= a_pos){
                a_mesh.position.x = 1.002*a_mesh.position.x
                a_mesh.position.y = 1.002*a_mesh.position.y
                a_mesh.position.z -= 0.25
                setTimeout(()=>{goBack(a_mesh, a_pos)},10)
            }
        }
        
        /*
            ######################################################
            ### Placing objects
        */
       
        placeSmth = (a_slot) => {
            if(slots[slotC][0] != 0 && slots[slotC][1] > 0 && cubeGrid[a_slot]["type"] == "none"){
                switch(slots[slotC][0]){
                    case 10:
                        x = BABYLON.MeshBuilder.CreateBox("reflector", {}, scene);
                        x.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1],gridPos[a_slot][2]-1);
                        x.scaling  = vec3(GRIDWID-0.5, 0.1, 0.5);
                        x.rotation = vec3(0,0,Math.PI*0.25)
                        x.material = reflMat;
                        x.isPickable = false
                        cubeGrid[a_slot] = {"type":"reflector","how":0,"destructable":false}
                        break;
                }
                slots[slotC][1]--;
                changeText("slotS"+slotC,slots[slotC][1],7,C[1],32);
                startLaser()
            }
        }
       
        /*
            ######################################################
            ### Process level
        */
        
        startLaser = () => {
            let a = scene.getMeshByName("laserLines")
            if(a){
                a.dispose()
            }
            for(var i=0; i<lasers.length; i++){
                var path = []
                var slote = lasers[i]["slot"];
                var pos = gridPos[lasers[i]["slot"]].slice();
                var dir = lasers[i]["dir"]
                path.push(pos.slice());
                isFine = 100
                while(isFine){
                    switch(dir){
                        case 0:
                            if(slote+GRIDSIZE > GRIDSIZE**2){
                                isFine = false
                                pos[1] += GRIDWID/2;
                            } else {
                                slote += GRIDSIZE
                                if(cubeGrid[slote]["type"] == "reflector"){
                                    dir = 3
                                }
                                pos[1] += GRIDWID;
                            }
                            break;
                        case 1:
                            if((slote-1)%GRIDSIZE > slote%GRIDSIZE){
                                isFine = false
                                pos[0] -= GRIDWID/2;
                            } else {
                                slote -= 1
                                if(cubeGrid[slote]["type"] == "reflector"){
                                    dir = 2
                                }
                                pos[0] -= GRIDWID;
                            }
                            break;
                        case 2:
                            if(slote-GRIDSIZE < 0){
                                isFine = false
                                pos[1] -= GRIDWID/2;
                            } else {
                                slote -= GRIDSIZE
                                if(cubeGrid[slote]["type"] == "reflector"){
                                    dir = 1
                                }
                                pos[1] -= GRIDWID;
                            }
                            break;
                        case 3:
                            if((slote+1)%GRIDSIZE < slote%GRIDSIZE){
                                isFine = false
                                pos[0] += GRIDWID/2;
                            } else {
                                slote += 1
                                if(cubeGrid[slote]["type"] == "reflector"){
                                    dir = 0
                                }
                                pos[0] += GRIDWID;
                            }
                            break;
                    }
                    if(isFine){ isFine--; }
                    path.push(pos.slice());
                }
                for(var j=0;j<path.length;j++){
                    path[j] = {'x':path[j][0],'y':path[j][1],'z':path[j][2]};
                }
                var zz = BABYLON.MeshBuilder.CreateLines("laserLines", {points: path}, scene);
            }
        }
        
        createEntr = (a_slot, a_fau) => {
            var y = BABYLON.MeshBuilder.CreateBox("gridEntryFaucet", {}, scene);
                y.scaling  = vec3(0.4, 0.4, 1.5);
                y.material = entrMat;
                y.isPickable = false
            switch(a_fau){
                case 0:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]+1,gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"entry","where":0,"destructable":false}
                    lasers.push({"slot":a_slot,"dir":0})
                    break;
                case 1:
                    y.position = vec3(gridPos[a_slot][0]-1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"entry","where":1,"destructable":false}
                    lasers.push({"slot":a_slot,"dir":1})
                    break;
                case 2:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]-1,gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"entry","where":2,"destructable":false}
                    lasers.push({"slot":a_slot,"dir":2})
                    break;
                case 3:
                    y.position = vec3(gridPos[a_slot][0]+1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    cubeGrid[a_slot] = {"type":"entry","where":3,"destructable":false}
                    lasers.push({"slot":a_slot,"dir":3})
                    break;
            }
            var x = BABYLON.MeshBuilder.CreateBox("gridEntry", {}, scene);
                x.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1],gridPos[a_slot][2]);
                x.scaling  = vec3(GRIDWID-2, GRIDWID-2, 2);
                x.material = entrMat;
                x.isPickable = false
        }
        
        createExit = (a_slot, a_fau) => {
            var y = BABYLON.MeshBuilder.CreateBox("gridExitFaucet", {}, scene);
                y.scaling  = vec3(0.4, 0.4, 1.5);
                y.material = exitMat;
                y.isPickable = false
            switch(a_fau){
                case 0:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]+1,gridPos[a_slot][2]);
                    break;
                case 1:
                    y.position = vec3(gridPos[a_slot][0]-1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    break;
                case 2:
                    y.position = vec3(gridPos[a_slot][0],gridPos[a_slot][1]-1,gridPos[a_slot][2]);
                    break;
                case 3:
                    y.position = vec3(gridPos[a_slot][0]+1,gridPos[a_slot][1],gridPos[a_slot][2]);
                    break;
            }
            var x = BABYLON.MeshBuilder.CreateBox("gridExit", {}, scene);
                x.position = vec3(gridPos[a_slot][0], gridPos[a_slot][1], gridPos[a_slot][2]);
                x.scaling  = vec3(GRIDWID-2, GRIDWID-2, 2);
                x.material = exitMat;
                x.isPickable = false
        }
        
        processLevel = () => {
            var data = LEVELS[level][0];
            var slotk = 0;
            var blk = 0;
            for(var i=0; i<data.length; i++){
                do{
                    if(data[i]&1){
                        switch(LEVELS[level][1][blk]){
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                createEntr(slotk, LEVELS[level][1][blk]-1)
                                break;
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                                createExit(slotk, LEVELS[level][1][blk]-5)
                                break;
                            case 9:
                                x = BABYLON.MeshBuilder.CreateBox("gridWall", {}, scene);
                                x.position = vec3(gridPos[slotk][0],gridPos[slotk][1],gridPos[slotk][2]);
                                x.scaling  = vec3(GRIDWID-0.5, GRIDWID-0.5, 2);
                                x.material = wallMat;
                                x.isPickable = false
                                break;
                            default:
                                x = BABYLON.MeshBuilder.CreateBox("gridPoz", {}, scene);
                                x.position = vec3(gridPos[slotk][0],gridPos[slotk][1],gridPos[slotk][2]);
                                x.scaling  = vec3(GRIDWID-0.25, GRIDWID-0.25, 0.25);
                                x.material = logoMaterials[ranRng(5)];
                                x.isPickable = false
                                break;
                        }
                        blk++;
                    }
                    data[i] >>= 1;
                    slotk++;
                }while(slotk%32 != 0);
            }
            for(var i=0; i<LEVELS[level][2].length; i+=2){
                slots[Math.floor(i/2)] = [LEVELS[level][2][i], LEVELS[level][2][i+1]]
                changeText("slotT"+Math.floor(i/2),whatName(LEVELS[level][2][i]),7,C[0],36)
                changeText("slotS"+Math.floor(i/2),LEVELS[level][2][i+1],7,C[1],32)
            }
            chooseSlot(0)
        }
        
        /*
            ######################################################
            ### Game states funtions
        */
        
        drawSlots = () => {
            for(var i=0; i<5; i++){
                var plane = BABYLON.MeshBuilder.CreatePlane("slot"+i, {sideOrientation: 3}, scene);
                    plane.scaling    = vec3(3, 3, 1)
                    plane.position   = vec3(24, 6-i*3.25, -30);
                    plane.visibility = 0.5;
                    drawText("slotT"+i, "", C[0], 7, vec3(20.5, 6.5-i*3.25, -32.5), Math.PI*0.8, 30);
                    drawText("slotS"+i, "", C[0], 7, vec3(20.5, 5.6-i*3.25, -32.5), Math.PI*0.8, 36);
                    plane.material   = eqSlot
                    plane.rotation.y = Math.PI*0.8;
            }
        }
        
        // Create Logo
        createLogo = () => {
            for(var i=0; i<5; i++){
                var z = -12
                do{
                    if(logo[i]&1){
                        x = BABYLON.MeshBuilder.CreateBox("logo", {}, scene);
                        x.position = vec3(z*1.2, i*1.2, -40);
                        x.scaling  = vec3(1.2, 1.2, 0.25);
                        x.material = logoMaterials[ranRng(5)];
                        hl.addMesh(x, tex(1, 1, 1));
                    }
                    z++;
                }while(logo[i]>>=1)
            }
            drawText("logoClick", S[0], "#ffffff", 24, vec3(0, -2, -40), Math.PI);
            drawText("storageLabel", S[1], C[1], 10, vec3(-20, -6, -30), Math.PI*1.2, 40);
            drawText("toolbarLabel", S[2], C[1], 10, vec3(20, 8, -30), Math.PI*0.8, 40);
            drawText("storage", "0/"+maxS+" B", C[0], 10, vec3(-20, -5, -30), Math.PI*1.2);
            drawSlots();
            gameState = 1;
        }
        createLogo();
        
        startGame = (a_label) => {
            goBackFog(90);
            scene.meshes.forEach(function(m){
                if(m.name == "logo"){
                    m.position.y += 50;
                    m.position.z -= 100;
                    hl.removeMesh(m);
                } else if(m.name == "data"){
                    goBack(m, -100)
                }
            });
            a_label.dispose();
            var mati2 = mate("gridMat");
                mati2.emissiveColor   = tex(0.07, 0.07, 0.12); //tex(0.05, 0.16, 0.30)
                mati2.disableLighting = true;
            var x = BABYLON.MeshBuilder.CreateBox("gridBack", {}, scene);
                x.position = vec3(0, 0, -50);
                x.scaling  = vec3(GRIDWID*GRIDSIZE+4, GRIDWID*GRIDSIZE+4, 0.25);
                x.material = mati2;
                x.visibility = 0.9
            for(var i=0; i<GRIDSIZE; i++){
                for(var j=0; j<GRIDSIZE; j++){
                    let x = BABYLON.MeshBuilder.CreateBox("gridZ"+(i*8+j), {}, scene);
                        x.position = vec3(GRIDWID*(j-GRIDSIZE/2)+GRIDWID/2, GRIDWID*(i-GRIDSIZE/2)+GRIDWID/2, -45);
                        gridPos.push([GRIDWID*(j-GRIDSIZE/2)+GRIDWID/2, GRIDWID*(i-GRIDSIZE/2)+GRIDWID/2, -44])
                        x.scaling  = vec3(GRIDWID-0.25, GRIDWID-0.25, 0.25);
                        x.material = nonGrid;
                        x.visibility = 0.98
                }
            }
            processLevel();
        }
        
        /*
            ######################################################
            ### Engine functions
        */

        // Register a render loop to repeatedly render the scene
        engine.runRenderLoop(() => {
            // Display FPS
            var fpsLabel = document.getElementById("fps");
            fpsLabel.innerHTML = engine.getFps().toFixed() + " fps";
            
            // Update meshes
            var pickResult = scene.pick(scene.pointerX, scene.pointerY);
            scene.meshes.forEach(function(m){
                if(m.name == "logo" && Math.random() <= 0.005){
                    m.material = logoMaterials[ranRng(5)]
                } else if(m.name == "data"){
                    m.position.x += (Math.random()-0.5)*0.025
                } else if(m.name == "grid"){
                    m.material = nonGrid;
                }
            });
            
            // Board grid selected update
            //var pi = scene.pick(scene.pointerX, scene.pointerY);
            var pi = scene.pick(can.width/2, can.height/2);
            if(pi.pickedMesh){
                if(pi.pickedMesh.name == "grid"){
                    pi.pickedMesh.material = selGrid;
                }
            }
            
            // Shake camera
            switch(shakeCamera){
                case 1:
                    camera.position = vec3(randS()*0.05, randS()*0.05, 1+randS()*0.05);
                    break;
                case 2:
                    camera.position = vec3(randS()*0.1, randS()*0.1, 1+randS()*0.1);
                    break;
                case 3:
                    camera.position = vec3(randS()*0.2, randS()*0.2, 1+randS()*0.2);
                    break;
            }
            
            // Render scene
            scene.render();
        });

        /*
            ######################################################
            ### Window Events
        */
        
        // Watch for browser/canvas resize events
        window.addEventListener("resize", function() {
            can.width = window.innerWidth;
            can.height = window.innerHeight;
            engine.resize();
        });

        // On window click
        window.addEventListener("click", function(){
            //var pi = scene.pick(scene.pointerX, scene.pointerY);
            var pi = scene.pick(can.width/2, can.height/2);
            if(pi.pickedMesh){
                var nme = pi.pickedMesh.name;
                if(nme == "logoClick"){
                    startGame(pi.pickedMesh);
                } else if(nme == "slot0" || nme == "slotT0" || nme == "slotS0"){
                    chooseSlot(0)
                } else if(nme == "slot1" || nme == "slotT1" || nme == "slotS1"){
                    chooseSlot(1)
                } else if(nme == "slot2" || nme == "slotT2" || nme == "slotS2"){
                    chooseSlot(2)
                } else if(nme == "slot3" || nme == "slotT3" || nme == "slotS3"){
                    chooseSlot(3)
                } else if(nme == "slot4" || nme == "slotT4" || nme == "slotS4"){
                    chooseSlot(4)
                } else if(nme.split("Z")[0] == "grid"){
                    placeSmth(Number(nme.split("Z")[1]))
                }
            }
            
            can.requestPointerLock = can.requestPointerLock ||
            can.mozRequestPointerLock ||
            can.webkitRequestPointerLock;
            // Ask the browser to lock the pointer
            can.requestPointerLock();
        })
        /*
            FOR LATER USE
            
            changeText("storage",actS+"/"+maxS+" B",10,"#ffffff")
            scene.getAnimationRatio()
            if (/slot[ST]?4/.test(nme))
        */
    </script>
</html>